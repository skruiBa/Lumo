"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@gradio";
exports.ids = ["vendor-chunks/@gradio"];
exports.modules = {

/***/ "(rsc)/./node_modules/@gradio/client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@gradio/client/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   FileData: () => (/* binding */ FileData),\n/* harmony export */   client: () => (/* binding */ client),\n/* harmony export */   duplicate: () => (/* binding */ duplicate_space),\n/* harmony export */   handle_file: () => (/* binding */ handle_file),\n/* harmony export */   predict: () => (/* binding */ predict),\n/* harmony export */   prepare_files: () => (/* binding */ prepare_files),\n/* harmony export */   submit: () => (/* binding */ submit),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   upload_files: () => (/* binding */ upload_files)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, { numeric: 1 }).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = \"host\";\nconst UPLOAD_URL = \"upload\";\nconst LOGIN_URL = \"login\";\nconst CONFIG_URL = \"config\";\nconst API_INFO_URL = \"info\";\nconst RUNTIME_URL = \"runtime\";\nconst SLEEPTIME_URL = \"sleeptime\";\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...cookies ? { Cookie: cookies } : {}\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({ api_name, id }) => {\n    if (api_name)\n      apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return { ...config, path };\n  } else if (endpoint) {\n    const config_url = join_urls(endpoint, CONFIG_URL);\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const { http_protocol, host } = await process_endpoint(\n    this.app_reference,\n    this.options.hf_token\n  );\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(\n        http_protocol,\n        host,\n        this.options.auth,\n        this.fetch,\n        this.options.hf_token\n      );\n      if (cookie_header)\n        this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const { protocol, host, pathname } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst parse_and_set_cookies = (cookie_header) => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach((cookie) => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(\n        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,\n        { headers }\n      );\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach((category) => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(\n        ([endpoint, { parameters, returns }]) => {\n          var _a, _b, _c, _d;\n          const dependencyIndex = ((_a = config.dependencies.find(\n            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\")\n          )) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };\n          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(\n              (input) => {\n                var _a2;\n                return (_a2 = config.components.find((c) => c.id === input)) == null ? void 0 : _a2.type;\n              }\n            );\n            try {\n              components.forEach((comp, idx) => {\n                if (comp === \"state\") {\n                  const new_param = {\n                    component: \"state\",\n                    example: null,\n                    parameter_default: null,\n                    parameter_has_default: true,\n                    parameter_name: null,\n                    hidden: true\n                  };\n                  parameters.splice(idx, 0, new_param);\n                }\n              });\n            } catch (e) {\n              console.error(e);\n            }\n          }\n          const transform_type = (data, component, serializer, signature_type) => ({\n            ...data,\n            description: get_description(data == null ? void 0 : data.type, serializer),\n            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n          });\n          transformed_info[category][endpoint] = {\n            parameters: parameters.map(\n              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")\n            ),\n            returns: returns.map(\n              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")\n            ),\n            type: dependencyTypes\n          };\n        }\n      );\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return { type: \"log\", data };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return { type: \"none\", status: { stage: \"error\", queue } };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(\n        `No value provided for required parameter: ${param.parameter_name}`\n      );\n    }\n  });\n  provided_keys.forEach((key) => {\n    if (!parameters.some((param) => param.parameter_name === key)) {\n      throw new Error(\n        `Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`\n      );\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(\n        `No value provided for required parameter: ${parameters[idx].parameter_name}`\n      );\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info)\n    return this.api_info;\n  const { hf_token } = this.options;\n  const { config } = this;\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    \"Could not get API info. \" + e.message;\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach((file) => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return { error: `HTTP ${response.status}: ${error_text}` };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return { files: uploadResponses };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\n    (file_data2) => file_data2.blob\n  );\n  const oversized_files = files.filter(\n    (f) => f.size > (max_file_size ?? Infinity)\n  );\n  if (oversized_files.length) {\n    throw new Error(\n      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(\", \")}`\n    );\n  }\n  return await Promise.all(\n    await this.upload_files(root_url, files, upload_id).then(\n      async (response) => {\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          if (response.files) {\n            return response.files.map((f, i) => {\n              const file = new FileData({\n                ...file_data[i],\n                path: f,\n                url: root_url + \"/file=\" + f\n              });\n              return file;\n            });\n          }\n          return [];\n        }\n      }\n    )\n  );\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(\n    (f) => new FileData({\n      path: f.name,\n      orig_name: f.name,\n      blob: f,\n      size: f.size,\n      mime_type: f.type,\n      is_stream\n    })\n  );\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"meta\", { _type: \"gradio.FileData\" });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(\n      data.map(async (_, index) => {\n        var _a;\n        let new_path = path.slice();\n        new_path.push(String(index));\n        const array_refs = await walk_and_store_blobs(\n          data[index],\n          root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type,\n          new_path,\n          false,\n          endpoint_info\n        );\n        blob_refs = blob_refs.concat(array_refs);\n      })\n    );\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [\n      {\n        path,\n        blob: new Blob([data]),\n        type\n      }\n    ];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(\n        await walk_and_store_blobs(\n          value,\n          void 0,\n          new_path,\n          false,\n          endpoint_info\n        )\n      );\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find((dep) => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({ data }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: { _type: \"gradio.FileData\" }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\n    \"Invalid input: must be a URL, File, Blob, or Buffer object.\"\n  );\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find((c) => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(\n    data,\n    void 0,\n    [],\n    true,\n    api_info\n  );\n  const results = await Promise.all(\n    blobRefs.map(async ({ path, blob, type }) => {\n      if (!blob)\n        return { path, type };\n      const response = await self.upload_files(endpoint, [blob]);\n      const file_url = response.files && response.files[0];\n      return {\n        path,\n        file_url,\n        type,\n        name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n      };\n    })\n  );\n  results.forEach(({ path, file_url, type, name }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({ path: file_url, orig_name: name });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs/promises */ \"fs/promises\", 19));\n      const path = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ \"path\", 19));\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], { type: \"application/octet-stream\" });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: { ...headers, ...additional_headers },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{ error: BROKEN_CONNECTION_MSG }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = { error: `Could not parse server response: ${e}` };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(\n      (dep) => dep.id == this.api_map[trimmed_endpoint]\n    );\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\")\n          reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200)\n    return;\n  const {\n    runtime: { stage },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise((resolve) => {\n    check_space_status(\n      space_id,\n      RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n      (status) => {\n        status_callback(status);\n        if (status.status === \"running\") {\n          resolve();\n        } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n          resolve();\n        } else if (status.status === \"sleeping\" || status.status === \"building\") {\n          if (retries < max_retries) {\n            retries++;\n            setTimeout(() => {\n              check_and_wake_space(space_id, status_callback).then(resolve);\n            }, check_interval);\n          } else {\n            resolve();\n          }\n        }\n      }\n    );\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    );\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))\n      return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,\n      { headers }\n    );\n    if (res.status !== 200)\n      throw new Error(\"Space hardware could not be obtained.\");\n    const { hardware } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify(body)\n      }\n    );\n    if (res.status !== 200) {\n      throw new Error(\n        \"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\"\n      );\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\n  \"cpu-basic\",\n  \"cpu-upgrade\",\n  \"cpu-xl\",\n  \"t4-small\",\n  \"t4-medium\",\n  \"a10g-small\",\n  \"a10g-large\",\n  \"a10g-largex2\",\n  \"a10g-largex4\",\n  \"a100-large\",\n  \"zero-a10g\",\n  \"h100\",\n  \"h100x8\"\n];\nasync function duplicate(app_reference, options) {\n  const { hf_token, private: _private, hardware, timeout, auth } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\n    );\n  }\n  const { http_protocol, host } = await process_endpoint(\n    app_reference,\n    hf_token\n  );\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(\n      http_protocol,\n      host,\n      auth,\n      fetch\n    );\n    if (cookie_header)\n      cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...cookies ? { Cookie: cookies.join(\"; \") } : {}\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\n      {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n      }\n    );\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(\n      get_space_reference(duplicated_space.url),\n      options\n    );\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = { allowCR: false }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1)\n            break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: (controller) => {\n        if (__privateGet(this, _currentLine) === \"\")\n          return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({ allowCR: true });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [\n      input.substring(0, idx),\n      input.substring(idx + match[0].length)\n    ];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp)\n    headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body)\n    return;\n  let iter = stream$1(res.body);\n  let line, reader = iter.getReader();\n  let event;\n  for (; ; ) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done)\n      return;\n    if (!line.value) {\n      if (event)\n        yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field)\n      continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok)\n    throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}/queue/data?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function(event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(\n        Object.keys(event_callbacks).map(\n          (event_id2) => event_callbacks[event_id2](_data)\n        )\n      );\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(\n        config.protocol\n      )) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function() {\n    await Promise.all(\n      Object.keys(event_callbacks).map(\n        (event_id) => event_callbacks[event_id]({\n          msg: \"unexpected_error\",\n          message: BROKEN_CONNECTION_MSG\n        })\n      )\n    );\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async (res) => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch((e) => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function(event) {\n      if (all_events || events_to_publish[event.type]) {\n        push_event(event);\n      }\n    }, close = function() {\n      done = true;\n      while (resolvers.length > 0)\n        resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n    }, push = function(data2) {\n      if (done)\n        return;\n      if (resolvers.length > 0) {\n        resolvers.shift()(data2);\n      } else {\n        values.push(data2);\n      }\n    }, push_error = function(error) {\n      push(thenable_reject(error));\n      close();\n    }, push_event = function(event) {\n      push({ value: event, done: false });\n    }, next = function() {\n      if (values.length > 0)\n        return Promise.resolve(values.shift());\n      if (done)\n        return Promise.resolve({ value: void 0, done: true });\n      return new Promise((resolve) => resolvers.push(resolve));\n    };\n    const { hf_token } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options\n    } = this;\n    const that = this;\n    if (!api_info)\n      throw new Error(\"No API found\");\n    if (!config)\n      throw new Error(\"Could not resolve app config\");\n    let { fn_index, endpoint_info, dependency } = get_endpoint_info(\n      api_info,\n      endpoint,\n      api_map,\n      config\n    );\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce(\n      (acc, event) => {\n        acc[event] = true;\n        return acc;\n      },\n      {}\n    )) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */ new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = { fn_index, session_hash };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = { event_id };\n        cancel_request = { event_id, session_hash, fn_index };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}/cancel`, {\n            headers: { \"Content-Type\": \"application/json\" },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}/reset`, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\n          \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\n        );\n      }\n    }\n    const resolve_heartbeat = async (config2) => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config)\n        return;\n      let render_id = render_config.render_id;\n      config.components = [\n        ...config.components.filter((c) => c.props.rendered_in !== render_id),\n        ...render_config.components\n      ];\n      config.dependencies = [\n        ...config.dependencies.filter((d) => d.rendered_in !== render_id),\n        ...render_config.dependencies\n      ];\n      const any_state = config.components.some((c) => c.type === \"state\");\n      const any_unload = config.dependencies.some(\n        (d) => d.targets.some((t) => t[1] === \"unload\")\n      );\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(\n      async (_payload) => {\n        var _a2;\n        let input_data = handle_payload(\n          _payload,\n          dependency,\n          config.components,\n          \"input\",\n          true\n        );\n        payload = {\n          data: input_data || [],\n          event_data,\n          fn_index,\n          trigger_id\n        };\n        if (skip_queue(fn_index, config)) {\n          fire_event({\n            type: \"status\",\n            endpoint: _endpoint,\n            stage: \"pending\",\n            queue: false,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          post_data2(\n            `${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\n            {\n              ...payload,\n              session_hash\n            }\n          ).then(([output, status_code]) => {\n            const data2 = output.data;\n            if (status_code == 200) {\n              fire_event({\n                type: \"data\",\n                endpoint: _endpoint,\n                fn_index,\n                data: handle_payload(\n                  data2,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                time: /* @__PURE__ */ new Date(),\n                event_data,\n                trigger_id\n              });\n              if (output.render_config) {\n                handle_render_config(output.render_config);\n              }\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                stage: \"complete\",\n                eta: output.average_duration,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                endpoint: _endpoint,\n                fn_index,\n                message: output.error,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          }).catch((e) => {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: e.message,\n              endpoint: _endpoint,\n              fn_index,\n              queue: false,\n              time: /* @__PURE__ */ new Date()\n            });\n          });\n        } else if (protocol == \"ws\") {\n          const { ws_protocol, host } = await process_endpoint(\n            app_reference,\n            hf_token\n          );\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let url = new URL(\n            `${ws_protocol}://${resolve_root(\n              host,\n              config.path,\n              true\n            )}/queue/join${url_params ? \"?\" + url_params : \"\"}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          websocket = new WebSocket(url);\n          websocket.onclose = (evt) => {\n            if (!evt.wasClean) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                broken: true,\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          };\n          websocket.onmessage = function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                websocket.close();\n              }\n            } else if (type === \"hash\") {\n              websocket.send(JSON.stringify({ fn_index, session_hash }));\n              return;\n            } else if (type === \"data\") {\n              websocket.send(JSON.stringify({ ...payload, session_hash }));\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                websocket.close();\n              }\n            }\n          };\n          if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n            addEventListener(\n              \"open\",\n              () => websocket.send(JSON.stringify({ hash: session_hash }))\n            );\n          }\n        } else if (protocol == \"sse\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          var params = new URLSearchParams({\n            fn_index: fn_index.toString(),\n            session_hash\n          }).toString();\n          let url = new URL(\n            `${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          stream2 = this.stream(url);\n          if (!stream2) {\n            return Promise.reject(\n              new Error(\"Cannot connect to SSE endpoint: \" + url.toString())\n            );\n          }\n          stream2.onmessage = async function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"data\") {\n              event_id = _data.event_id;\n              let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n                ...payload,\n                session_hash,\n                event_id\n              });\n              if (status2 !== 200) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */ new Date()\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            }\n          };\n        } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let hostname = \"\";\n          if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n            hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n          }\n          let hfhubdev = \"dev.spaces.huggingface.tech\";\n          const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n          const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\n          const is_zerogpu_space = dependency.zerogpu && config.space_id;\n          const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n          const post_data_promise = zerogpu_auth_promise.then((headers) => {\n            return post_data2(\n              `${config.root}/queue/join?${url_params}`,\n              {\n                ...payload,\n                session_hash\n              },\n              headers\n            );\n          });\n          post_data_promise.then(async ([response, status]) => {\n            if (status === 503) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: QUEUE_FULL_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else if (status !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              event_id = response.event_id;\n              let callback = async function(_data) {\n                try {\n                  const { type, status: status2, data: data2 } = handle_message(\n                    _data,\n                    last_status[fn_index]\n                  );\n                  if (type == \"heartbeat\") {\n                    return;\n                  }\n                  if (type === \"update\" && status2 && !complete) {\n                    fire_event({\n                      type: \"status\",\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2\n                    });\n                  } else if (type === \"complete\") {\n                    complete = status2;\n                  } else if (type == \"unexpected_error\") {\n                    console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date()\n                    });\n                  } else if (type === \"log\") {\n                    fire_event({\n                      type: \"log\",\n                      log: data2.log,\n                      level: data2.level,\n                      endpoint: _endpoint,\n                      duration: data2.duration,\n                      visible: data2.visible,\n                      fn_index\n                    });\n                    return;\n                  } else if (type === \"generating\") {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2 && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                      apply_diff_stream(pending_diff_streams, event_id, data2);\n                    }\n                  }\n                  if (data2) {\n                    fire_event({\n                      type: \"data\",\n                      time: /* @__PURE__ */ new Date(),\n                      data: handle_payload(\n                        data2.data,\n                        dependency,\n                        config.components,\n                        \"output\",\n                        options.with_null_state\n                      ),\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2.render_config) {\n                      await handle_render_config(data2.render_config);\n                    }\n                    if (complete) {\n                      fire_event({\n                        type: \"status\",\n                        time: /* @__PURE__ */ new Date(),\n                        ...complete,\n                        stage: status2 == null ? void 0 : status2.stage,\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      close();\n                    }\n                  }\n                  if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                    if (event_callbacks[event_id]) {\n                      delete event_callbacks[event_id];\n                    }\n                    if (event_id in pending_diff_streams) {\n                      delete pending_diff_streams[event_id];\n                    }\n                  }\n                } catch (e) {\n                  console.error(\"Unexpected client exception\", e);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                  if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    close_stream(stream_status, that.abort_controller);\n                    stream_status.open = false;\n                    close();\n                  }\n                }\n              };\n              if (event_id in pending_stream_messages) {\n                pending_stream_messages[event_id].forEach(\n                  (msg) => callback(msg)\n                );\n                delete pending_stream_messages[event_id];\n              }\n              event_callbacks[event_id] = callback;\n              unclosed_events.add(event_id);\n              if (!stream_status.open) {\n                await this.open_stream();\n              }\n            }\n          });\n        }\n      }\n    );\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async (value) => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(\n      (dep) => dep.id == api_map[trimmed_endpoint]\n    );\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\n      \"There is no endpoint matching that name of fn_index matching that number.\"\n    );\n  }\n  return { fn_index, endpoint_info, dependency };\n}\nclass Client {\n  constructor(app_reference, options = { events: [\"data\"] }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", { open: false });\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */ new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    this.app_reference = app_reference;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    return fetch(input, { ...init, headers });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@gradio\").then(__webpack_require__.bind(__webpack_require__, /*! ./wrapper-CviSselG.js */ \"(rsc)/./node_modules/@gradio/client/dist/wrapper-CviSselG.js\"));\n      global.WebSocket = ws.WebSocket;\n    }\n    try {\n      if (this.options.auth) {\n        await this.resolve_cookies();\n      }\n      await this._resolve_config().then(\n        ({ config }) => this._resolve_hearbeat(config)\n      );\n    } catch (e) {\n      throw Error(e);\n    }\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(\n            this.config.space_id,\n            this.options.hf_token,\n            this.cookies\n          );\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(\n        `${this.config.root}/heartbeat/${this.session_hash}`\n      );\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const { http_protocol, host, space_id } = await process_endpoint(\n      this.app_reference,\n      this.options.hf_token\n    );\n    const { status_callback } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      config = await this.resolve_config(`${http_protocol}//${host}`);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(\n          space_id,\n          RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n          this.handle_space_success\n        );\n      } else {\n        if (status_callback)\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const { status_callback } = this.options;\n    if (status_callback)\n      status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const { hf_token } = this.options;\n    const { session_hash } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(\n      (comp) => comp.id === component_id\n    );\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\")\n          continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(`${root_url}/component_server/`, {\n        method: \"POST\",\n        body,\n        headers,\n        credentials: \"include\"\n      });\n      if (!response.ok) {\n        throw new Error(\n          \"Could not connect to component server: \" + response.statusText\n        );\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdyYWRpby9jbGllbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkMsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QixzQkFBc0IsSUFBSTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLGVBQWU7QUFDM0I7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXJlYWN0LWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JhZGlvL2NsaWVudC9kaXN0L2luZGV4LmpzPzBhNTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX2N1cnJlbnRMaW5lO1xudmFyIGZuID0gbmV3IEludGwuQ29sbGF0b3IoMCwgeyBudW1lcmljOiAxIH0pLmNvbXBhcmU7XG5mdW5jdGlvbiBzZW1pdmVyKGEsIGIsIGJvb2wpIHtcbiAgYSA9IGEuc3BsaXQoXCIuXCIpO1xuICBiID0gYi5zcGxpdChcIi5cIik7XG4gIHJldHVybiBmbihhWzBdLCBiWzBdKSB8fCBmbihhWzFdLCBiWzFdKSB8fCAoYlsyXSA9IGIuc2xpY2UoMikuam9pbihcIi5cIiksIGJvb2wgPSAvWy4tXS8udGVzdChhWzJdID0gYS5zbGljZSgyKS5qb2luKFwiLlwiKSksIGJvb2wgPT0gL1suLV0vLnRlc3QoYlsyXSkgPyBmbihhWzJdLCBiWzJdKSA6IGJvb2wgPyAtMSA6IDEpO1xufVxuY29uc3QgSE9TVF9VUkwgPSBcImhvc3RcIjtcbmNvbnN0IFVQTE9BRF9VUkwgPSBcInVwbG9hZFwiO1xuY29uc3QgTE9HSU5fVVJMID0gXCJsb2dpblwiO1xuY29uc3QgQ09ORklHX1VSTCA9IFwiY29uZmlnXCI7XG5jb25zdCBBUElfSU5GT19VUkwgPSBcImluZm9cIjtcbmNvbnN0IFJVTlRJTUVfVVJMID0gXCJydW50aW1lXCI7XG5jb25zdCBTTEVFUFRJTUVfVVJMID0gXCJzbGVlcHRpbWVcIjtcbmNvbnN0IFNQQUNFX0ZFVENIRVJfVVJMID0gXCJodHRwczovL2dyYWRpby1zcGFjZS1hcGktZmV0Y2hlci12Mi5oZi5zcGFjZS9hcGlcIjtcbmNvbnN0IFFVRVVFX0ZVTExfTVNHID0gXCJUaGlzIGFwcGxpY2F0aW9uIGlzIGN1cnJlbnRseSBidXN5LiBQbGVhc2UgdHJ5IGFnYWluLiBcIjtcbmNvbnN0IEJST0tFTl9DT05ORUNUSU9OX01TRyA9IFwiQ29ubmVjdGlvbiBlcnJvcmVkIG91dC4gXCI7XG5jb25zdCBDT05GSUdfRVJST1JfTVNHID0gXCJDb3VsZCBub3QgcmVzb2x2ZSBhcHAgY29uZmlnLiBcIjtcbmNvbnN0IFNQQUNFX1NUQVRVU19FUlJPUl9NU0cgPSBcIkNvdWxkIG5vdCBnZXQgc3BhY2Ugc3RhdHVzLiBcIjtcbmNvbnN0IEFQSV9JTkZPX0VSUk9SX01TRyA9IFwiQ291bGQgbm90IGdldCBBUEkgaW5mby4gXCI7XG5jb25zdCBTUEFDRV9NRVRBREFUQV9FUlJPUl9NU0cgPSBcIlNwYWNlIG1ldGFkYXRhIGNvdWxkIG5vdCBiZSBsb2FkZWQuIFwiO1xuY29uc3QgSU5WQUxJRF9VUkxfTVNHID0gXCJJbnZhbGlkIFVSTC4gQSBmdWxsIFVSTCBwYXRoIGlzIHJlcXVpcmVkLlwiO1xuY29uc3QgVU5BVVRIT1JJWkVEX01TRyA9IFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgc3BhY2UuIFwiO1xuY29uc3QgSU5WQUxJRF9DUkVERU5USUFMU19NU0cgPSBcIkludmFsaWQgY3JlZGVudGlhbHMuIENvdWxkIG5vdCBsb2dpbi4gXCI7XG5jb25zdCBNSVNTSU5HX0NSRURFTlRJQUxTX01TRyA9IFwiTG9naW4gY3JlZGVudGlhbHMgYXJlIHJlcXVpcmVkIHRvIGFjY2VzcyB0aGlzIHNwYWNlLlwiO1xuY29uc3QgTk9ERUpTX0ZTX0VSUk9SX01TRyA9IFwiRmlsZSBzeXN0ZW0gYWNjZXNzIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5vZGUuanMgZW52aXJvbm1lbnRzXCI7XG5jb25zdCBST09UX1VSTF9FUlJPUl9NU0cgPSBcIlJvb3QgVVJMIG5vdCBmb3VuZCBpbiBjbGllbnQgY29uZmlnXCI7XG5jb25zdCBGSUxFX1BST0NFU1NJTkdfRVJST1JfTVNHID0gXCJFcnJvciB1cGxvYWRpbmcgZmlsZVwiO1xuZnVuY3Rpb24gcmVzb2x2ZV9yb290KGJhc2VfdXJsLCByb290X3BhdGgsIHByaW9yaXRpemVfYmFzZSkge1xuICBpZiAocm9vdF9wYXRoLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHJvb3RfcGF0aC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICByZXR1cm4gcHJpb3JpdGl6ZV9iYXNlID8gYmFzZV91cmwgOiByb290X3BhdGg7XG4gIH1cbiAgcmV0dXJuIGJhc2VfdXJsICsgcm9vdF9wYXRoO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0X2p3dChzcGFjZSwgdG9rZW4sIGNvb2tpZXMpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy8ke3NwYWNlfS9qd3RgLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAuLi5jb29raWVzID8geyBDb29raWU6IGNvb2tpZXMgfSA6IHt9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgand0ID0gKGF3YWl0IHIuanNvbigpKS50b2tlbjtcbiAgICByZXR1cm4gand0IHx8IGZhbHNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBtYXBfbmFtZXNfdG9faWRzKGZucykge1xuICBsZXQgYXBpcyA9IHt9O1xuICBmbnMuZm9yRWFjaCgoeyBhcGlfbmFtZSwgaWQgfSkgPT4ge1xuICAgIGlmIChhcGlfbmFtZSlcbiAgICAgIGFwaXNbYXBpX25hbWVdID0gaWQ7XG4gIH0pO1xuICByZXR1cm4gYXBpcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVfY29uZmlnKGVuZHBvaW50KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgaGVhZGVycyA9IHRoaXMub3B0aW9ucy5oZl90b2tlbiA/IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMub3B0aW9ucy5oZl90b2tlbn1gIH0gOiB7fTtcbiAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZ3JhZGlvX2NvbmZpZyAmJiBsb2NhdGlvbi5vcmlnaW4gIT09IFwiaHR0cDovL2xvY2FsaG9zdDo5ODc2XCIgJiYgIXdpbmRvdy5ncmFkaW9fY29uZmlnLmRldl9tb2RlKSB7XG4gICAgY29uc3QgcGF0aCA9IHdpbmRvdy5ncmFkaW9fY29uZmlnLnJvb3Q7XG4gICAgY29uc3QgY29uZmlnID0gd2luZG93LmdyYWRpb19jb25maWc7XG4gICAgbGV0IGNvbmZpZ19yb290ID0gcmVzb2x2ZV9yb290KGVuZHBvaW50LCBjb25maWcucm9vdCwgZmFsc2UpO1xuICAgIGNvbmZpZy5yb290ID0gY29uZmlnX3Jvb3Q7XG4gICAgcmV0dXJuIHsgLi4uY29uZmlnLCBwYXRoIH07XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnQpIHtcbiAgICBjb25zdCBjb25maWdfdXJsID0gam9pbl91cmxzKGVuZHBvaW50LCBDT05GSUdfVVJMKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goY29uZmlnX3VybCwge1xuICAgICAgaGVhZGVycyxcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIlxuICAgIH0pO1xuICAgIGlmICgocmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cykgPT09IDQwMSAmJiAhdGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0NSRURFTlRJQUxTX01TRyk7XG4gICAgfSBlbHNlIGlmICgocmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cykgPT09IDQwMSAmJiB0aGlzLm9wdGlvbnMuYXV0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfQ1JFREVOVElBTFNfTVNHKTtcbiAgICB9XG4gICAgaWYgKChyZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2Uuc3RhdHVzKSA9PT0gMjAwKSB7XG4gICAgICBsZXQgY29uZmlnID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uZmlnLnBhdGggPSBjb25maWcucGF0aCA/PyBcIlwiO1xuICAgICAgY29uZmlnLnJvb3QgPSBlbmRwb2ludDtcbiAgICAgIChfYSA9IGNvbmZpZy5kZXBlbmRlbmNpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChkZXAsIGkpID0+IHtcbiAgICAgICAgaWYgKGRlcC5pZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwLmlkID0gaTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH0gZWxzZSBpZiAoKHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMpID09PSA0MDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihVTkFVVEhPUklaRURfTVNHKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKENPTkZJR19FUlJPUl9NU0cpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihDT05GSUdfRVJST1JfTVNHKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVfY29va2llcygpIHtcbiAgY29uc3QgeyBodHRwX3Byb3RvY29sLCBob3N0IH0gPSBhd2FpdCBwcm9jZXNzX2VuZHBvaW50KFxuICAgIHRoaXMuYXBwX3JlZmVyZW5jZSxcbiAgICB0aGlzLm9wdGlvbnMuaGZfdG9rZW5cbiAgKTtcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICAgIGNvbnN0IGNvb2tpZV9oZWFkZXIgPSBhd2FpdCBnZXRfY29va2llX2hlYWRlcihcbiAgICAgICAgaHR0cF9wcm90b2NvbCxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgdGhpcy5vcHRpb25zLmF1dGgsXG4gICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgICAgIHRoaXMub3B0aW9ucy5oZl90b2tlblxuICAgICAgKTtcbiAgICAgIGlmIChjb29raWVfaGVhZGVyKVxuICAgICAgICB0aGlzLnNldF9jb29raWVzKGNvb2tpZV9oZWFkZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IEVycm9yKGUubWVzc2FnZSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldF9jb29raWVfaGVhZGVyKGh0dHBfcHJvdG9jb2wsIGhvc3QsIGF1dGgsIF9mZXRjaCwgaGZfdG9rZW4pIHtcbiAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9ybURhdGEuYXBwZW5kKFwidXNlcm5hbWVcIiwgYXV0aCA9PSBudWxsID8gdm9pZCAwIDogYXV0aFswXSk7XG4gIGZvcm1EYXRhLmFwcGVuZChcInBhc3N3b3JkXCIsIGF1dGggPT0gbnVsbCA/IHZvaWQgMCA6IGF1dGhbMV0pO1xuICBsZXQgaGVhZGVycyA9IHt9O1xuICBpZiAoaGZfdG9rZW4pIHtcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7aGZfdG9rZW59YDtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2goYCR7aHR0cF9wcm90b2NvbH0vLyR7aG9zdH0vJHtMT0dJTl9VUkx9YCwge1xuICAgIGhlYWRlcnMsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBmb3JtRGF0YSxcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCJcbiAgfSk7XG4gIGlmIChyZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICByZXR1cm4gcmVzLmhlYWRlcnMuZ2V0KFwic2V0LWNvb2tpZVwiKTtcbiAgfSBlbHNlIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9DUkVERU5USUFMU19NU0cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihTUEFDRV9NRVRBREFUQV9FUlJPUl9NU0cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVfcHJvdG9jb2woZW5kcG9pbnQpIHtcbiAgaWYgKGVuZHBvaW50LnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCwgaG9zdCwgcGF0aG5hbWUgfSA9IG5ldyBVUkwoZW5kcG9pbnQpO1xuICAgIGlmIChob3N0LmVuZHNXaXRoKFwiaGYuc3BhY2VcIikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdzX3Byb3RvY29sOiBcIndzc1wiLFxuICAgICAgICBob3N0LFxuICAgICAgICBodHRwX3Byb3RvY29sOiBwcm90b2NvbFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdzX3Byb3RvY29sOiBwcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwid3NzXCIgOiBcIndzXCIsXG4gICAgICBodHRwX3Byb3RvY29sOiBwcm90b2NvbCxcbiAgICAgIGhvc3Q6IGhvc3QgKyAocGF0aG5hbWUgIT09IFwiL1wiID8gcGF0aG5hbWUgOiBcIlwiKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdzX3Byb3RvY29sOiBcIndzXCIsXG4gICAgICBodHRwX3Byb3RvY29sOiBcImh0dHA6XCIsXG4gICAgICBob3N0OiBcImxpdGUubG9jYWxcIlxuICAgICAgLy8gU3BlY2lhbCBmYWtlIGhvc3RuYW1lIG9ubHkgdXNlZCBmb3IgdGhpcyBjYXNlLiBUaGlzIG1hdGNoZXMgdGhlIGhvc3RuYW1lIGFsbG93ZWQgaW4gYGlzX3NlbGZfaG9zdCgpYCBpbiBganMvd2FzbS9uZXR3b3JrL2hvc3QudHNgLlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3c19wcm90b2NvbDogXCJ3c3NcIixcbiAgICBodHRwX3Byb3RvY29sOiBcImh0dHBzOlwiLFxuICAgIGhvc3Q6IGVuZHBvaW50XG4gIH07XG59XG5jb25zdCBwYXJzZV9hbmRfc2V0X2Nvb2tpZXMgPSAoY29va2llX2hlYWRlcikgPT4ge1xuICBsZXQgY29va2llcyA9IFtdO1xuICBjb25zdCBwYXJ0cyA9IGNvb2tpZV9oZWFkZXIuc3BsaXQoLywoPz1cXHMqW15cXHM9O10rPVteXFxzPTtdKykvKTtcbiAgcGFydHMuZm9yRWFjaCgoY29va2llKSA9PiB7XG4gICAgY29uc3QgW2Nvb2tpZV9uYW1lLCBjb29raWVfdmFsdWVdID0gY29va2llLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIj1cIik7XG4gICAgaWYgKGNvb2tpZV9uYW1lICYmIGNvb2tpZV92YWx1ZSkge1xuICAgICAgY29va2llcy5wdXNoKGAke2Nvb2tpZV9uYW1lLnRyaW0oKX09JHtjb29raWVfdmFsdWUudHJpbSgpfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb29raWVzO1xufTtcbmNvbnN0IFJFX1NQQUNFX05BTUUgPSAvXlthLXpBLVowLTlfXFwtXFwuXStcXC9bYS16QS1aMC05X1xcLVxcLl0rJC87XG5jb25zdCBSRV9TUEFDRV9ET01BSU4gPSAvLipoZlxcLnNwYWNlXFwvezAsMX0kLztcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NfZW5kcG9pbnQoYXBwX3JlZmVyZW5jZSwgaGZfdG9rZW4pIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoaGZfdG9rZW4pIHtcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7aGZfdG9rZW59YDtcbiAgfVxuICBjb25zdCBfYXBwX3JlZmVyZW5jZSA9IGFwcF9yZWZlcmVuY2UudHJpbSgpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgaWYgKFJFX1NQQUNFX05BTUUudGVzdChfYXBwX3JlZmVyZW5jZSkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9zcGFjZXMvJHtfYXBwX3JlZmVyZW5jZX0vJHtIT1NUX1VSTH1gLFxuICAgICAgICB7IGhlYWRlcnMgfVxuICAgICAgKTtcbiAgICAgIGNvbnN0IF9ob3N0ID0gKGF3YWl0IHJlcy5qc29uKCkpLmhvc3Q7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFjZV9pZDogYXBwX3JlZmVyZW5jZSxcbiAgICAgICAgLi4uZGV0ZXJtaW5lX3Byb3RvY29sKF9ob3N0KVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoU1BBQ0VfTUVUQURBVEFfRVJST1JfTVNHKTtcbiAgICB9XG4gIH1cbiAgaWYgKFJFX1NQQUNFX0RPTUFJTi50ZXN0KF9hcHBfcmVmZXJlbmNlKSkge1xuICAgIGNvbnN0IHsgd3NfcHJvdG9jb2wsIGh0dHBfcHJvdG9jb2wsIGhvc3QgfSA9IGRldGVybWluZV9wcm90b2NvbChfYXBwX3JlZmVyZW5jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNwYWNlX2lkOiBob3N0LnJlcGxhY2UoXCIuaGYuc3BhY2VcIiwgXCJcIiksXG4gICAgICB3c19wcm90b2NvbCxcbiAgICAgIGh0dHBfcHJvdG9jb2wsXG4gICAgICBob3N0XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwYWNlX2lkOiBmYWxzZSxcbiAgICAuLi5kZXRlcm1pbmVfcHJvdG9jb2woX2FwcF9yZWZlcmVuY2UpXG4gIH07XG59XG5jb25zdCBqb2luX3VybHMgPSAoLi4udXJscykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiB1cmxzLnJlZHVjZSgoYmFzZV91cmwsIHBhcnQpID0+IHtcbiAgICAgIGJhc2VfdXJsID0gYmFzZV91cmwucmVwbGFjZSgvXFwvKyQvLCBcIlwiKTtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL15cXC8rLywgXCJcIik7XG4gICAgICByZXR1cm4gbmV3IFVSTChwYXJ0LCBiYXNlX3VybCArIFwiL1wiKS50b1N0cmluZygpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVJMX01TRyk7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1fYXBpX2luZm8oYXBpX2luZm8sIGNvbmZpZywgYXBpX21hcCkge1xuICBjb25zdCB0cmFuc2Zvcm1lZF9pbmZvID0ge1xuICAgIG5hbWVkX2VuZHBvaW50czoge30sXG4gICAgdW5uYW1lZF9lbmRwb2ludHM6IHt9XG4gIH07XG4gIE9iamVjdC5rZXlzKGFwaV9pbmZvKS5mb3JFYWNoKChjYXRlZ29yeSkgPT4ge1xuICAgIGlmIChjYXRlZ29yeSA9PT0gXCJuYW1lZF9lbmRwb2ludHNcIiB8fCBjYXRlZ29yeSA9PT0gXCJ1bm5hbWVkX2VuZHBvaW50c1wiKSB7XG4gICAgICB0cmFuc2Zvcm1lZF9pbmZvW2NhdGVnb3J5XSA9IHt9O1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXBpX2luZm9bY2F0ZWdvcnldKS5mb3JFYWNoKFxuICAgICAgICAoW2VuZHBvaW50LCB7IHBhcmFtZXRlcnMsIHJldHVybnMgfV0pID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgY29uc3QgZGVwZW5kZW5jeUluZGV4ID0gKChfYSA9IGNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZChcbiAgICAgICAgICAgIChkZXApID0+IGRlcC5hcGlfbmFtZSA9PT0gZW5kcG9pbnQgfHwgZGVwLmFwaV9uYW1lID09PSBlbmRwb2ludC5yZXBsYWNlKFwiL1wiLCBcIlwiKVxuICAgICAgICAgICkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pZCkgfHwgYXBpX21hcFtlbmRwb2ludC5yZXBsYWNlKFwiL1wiLCBcIlwiKV0gfHwgLTE7XG4gICAgICAgICAgY29uc3QgZGVwZW5kZW5jeVR5cGVzID0gZGVwZW5kZW5jeUluZGV4ICE9PSAtMSA/IChfYiA9IGNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gZGVwZW5kZW5jeUluZGV4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnR5cGVzIDogeyBnZW5lcmF0b3I6IGZhbHNlLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgICAgaWYgKGRlcGVuZGVuY3lJbmRleCAhPT0gLTEgJiYgKChfZCA9IChfYyA9IGNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gZGVwZW5kZW5jeUluZGV4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmlucHV0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgIT09IHBhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gY29uZmlnLmRlcGVuZGVuY2llcy5maW5kKChkZXApID0+IGRlcC5pZCA9PSBkZXBlbmRlbmN5SW5kZXgpLmlucHV0cy5tYXAoXG4gICAgICAgICAgICAgIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYTIgPSBjb25maWcuY29tcG9uZW50cy5maW5kKChjKSA9PiBjLmlkID09PSBpbnB1dCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTIudHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaCgoY29tcCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXAgPT09IFwic3RhdGVcIikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3X3BhcmFtID0ge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IFwic3RhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX2RlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcl9oYXNfZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX25hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3BsaWNlKGlkeCwgMCwgbmV3X3BhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1fdHlwZSA9IChkYXRhLCBjb21wb25lbnQsIHNlcmlhbGl6ZXIsIHNpZ25hdHVyZV90eXBlKSA9PiAoe1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBnZXRfZGVzY3JpcHRpb24oZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS50eXBlLCBzZXJpYWxpemVyKSxcbiAgICAgICAgICAgIHR5cGU6IGdldF90eXBlKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEudHlwZSwgY29tcG9uZW50LCBzZXJpYWxpemVyLCBzaWduYXR1cmVfdHlwZSkgfHwgXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybWVkX2luZm9bY2F0ZWdvcnldW2VuZHBvaW50XSA9IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMubWFwKFxuICAgICAgICAgICAgICAocCkgPT4gdHJhbnNmb3JtX3R5cGUocCwgcCA9PSBudWxsID8gdm9pZCAwIDogcC5jb21wb25lbnQsIHAgPT0gbnVsbCA/IHZvaWQgMCA6IHAuc2VyaWFsaXplciwgXCJwYXJhbWV0ZXJcIilcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zLm1hcChcbiAgICAgICAgICAgICAgKHIpID0+IHRyYW5zZm9ybV90eXBlKHIsIHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY29tcG9uZW50LCByID09IG51bGwgPyB2b2lkIDAgOiByLnNlcmlhbGl6ZXIsIFwicmV0dXJuXCIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdHlwZTogZGVwZW5kZW5jeVR5cGVzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRfaW5mbztcbn1cbmZ1bmN0aW9uIGdldF90eXBlKHR5cGUsIGNvbXBvbmVudCwgc2VyaWFsaXplciwgc2lnbmF0dXJlX3R5cGUpIHtcbiAgc3dpdGNoICh0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9XG4gIGlmIChzZXJpYWxpemVyID09PSBcIkpTT05TZXJpYWxpemFibGVcIiB8fCBzZXJpYWxpemVyID09PSBcIlN0cmluZ1NlcmlhbGl6YWJsZVwiKSB7XG4gICAgcmV0dXJuIFwiYW55XCI7XG4gIH0gZWxzZSBpZiAoc2VyaWFsaXplciA9PT0gXCJMaXN0U3RyaW5nU2VyaWFsaXphYmxlXCIpIHtcbiAgICByZXR1cm4gXCJzdHJpbmdbXVwiO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCA9PT0gXCJJbWFnZVwiKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV90eXBlID09PSBcInBhcmFtZXRlclwiID8gXCJCbG9iIHwgRmlsZSB8IEJ1ZmZlclwiIDogXCJzdHJpbmdcIjtcbiAgfSBlbHNlIGlmIChzZXJpYWxpemVyID09PSBcIkZpbGVTZXJpYWxpemFibGVcIikge1xuICAgIGlmICgodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS50eXBlKSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlX3R5cGUgPT09IFwicGFyYW1ldGVyXCIgPyBcIihCbG9iIHwgRmlsZSB8IEJ1ZmZlcilbXVwiIDogYHsgbmFtZTogc3RyaW5nOyBkYXRhOiBzdHJpbmc7IHNpemU/OiBudW1iZXI7IGlzX2ZpbGU/OiBib29sZWFuOyBvcmlnX25hbWU/OiBzdHJpbmd9W11gO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmF0dXJlX3R5cGUgPT09IFwicGFyYW1ldGVyXCIgPyBcIkJsb2IgfCBGaWxlIHwgQnVmZmVyXCIgOiBgeyBuYW1lOiBzdHJpbmc7IGRhdGE6IHN0cmluZzsgc2l6ZT86IG51bWJlcjsgaXNfZmlsZT86IGJvb2xlYW47IG9yaWdfbmFtZT86IHN0cmluZ31gO1xuICB9IGVsc2UgaWYgKHNlcmlhbGl6ZXIgPT09IFwiR2FsbGVyeVNlcmlhbGl6YWJsZVwiKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV90eXBlID09PSBcInBhcmFtZXRlclwiID8gXCJbKEJsb2IgfCBGaWxlIHwgQnVmZmVyKSwgKHN0cmluZyB8IG51bGwpXVtdXCIgOiBgW3sgbmFtZTogc3RyaW5nOyBkYXRhOiBzdHJpbmc7IHNpemU/OiBudW1iZXI7IGlzX2ZpbGU/OiBib29sZWFuOyBvcmlnX25hbWU/OiBzdHJpbmd9LCAoc3RyaW5nIHwgbnVsbCkpXVtdYDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0X2Rlc2NyaXB0aW9uKHR5cGUsIHNlcmlhbGl6ZXIpIHtcbiAgaWYgKHNlcmlhbGl6ZXIgPT09IFwiR2FsbGVyeVNlcmlhbGl6YWJsZVwiKSB7XG4gICAgcmV0dXJuIFwiYXJyYXkgb2YgW2ZpbGUsIGxhYmVsXSB0dXBsZXNcIjtcbiAgfSBlbHNlIGlmIChzZXJpYWxpemVyID09PSBcIkxpc3RTdHJpbmdTZXJpYWxpemFibGVcIikge1xuICAgIHJldHVybiBcImFycmF5IG9mIHN0cmluZ3NcIjtcbiAgfSBlbHNlIGlmIChzZXJpYWxpemVyID09PSBcIkZpbGVTZXJpYWxpemFibGVcIikge1xuICAgIHJldHVybiBcImFycmF5IG9mIGZpbGVzIG9yIHNpbmdsZSBmaWxlXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuZGVzY3JpcHRpb247XG59XG5mdW5jdGlvbiBoYW5kbGVfbWVzc2FnZShkYXRhLCBsYXN0X3N0YXR1cykge1xuICBjb25zdCBxdWV1ZSA9IHRydWU7XG4gIHN3aXRjaCAoZGF0YS5tc2cpIHtcbiAgICBjYXNlIFwic2VuZF9kYXRhXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiB9O1xuICAgIGNhc2UgXCJzZW5kX2hhc2hcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiaGFzaFwiIH07XG4gICAgY2FzZSBcInF1ZXVlX2Z1bGxcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIG1lc3NhZ2U6IFFVRVVFX0ZVTExfTVNHLFxuICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgY29kZTogZGF0YS5jb2RlLFxuICAgICAgICAgIHN1Y2Nlc3M6IGRhdGEuc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJoZWFydGJlYXRcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiaGVhcnRiZWF0XCJcbiAgICAgIH07XG4gICAgY2FzZSBcInVuZXhwZWN0ZWRfZXJyb3JcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5leHBlY3RlZF9lcnJvclwiLFxuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBkYXRhLm1lc3NhZ2UsXG4gICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJlc3RpbWF0aW9uXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICBzdGFnZTogbGFzdF9zdGF0dXMgfHwgXCJwZW5kaW5nXCIsXG4gICAgICAgICAgY29kZTogZGF0YS5jb2RlLFxuICAgICAgICAgIHNpemU6IGRhdGEucXVldWVfc2l6ZSxcbiAgICAgICAgICBwb3NpdGlvbjogZGF0YS5yYW5rLFxuICAgICAgICAgIGV0YTogZGF0YS5yYW5rX2V0YSxcbiAgICAgICAgICBzdWNjZXNzOiBkYXRhLnN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwicHJvZ3Jlc3NcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIHN0YWdlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICBjb2RlOiBkYXRhLmNvZGUsXG4gICAgICAgICAgcHJvZ3Jlc3NfZGF0YTogZGF0YS5wcm9ncmVzc19kYXRhLFxuICAgICAgICAgIHN1Y2Nlc3M6IGRhdGEuc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibG9nXCIsIGRhdGEgfTtcbiAgICBjYXNlIFwicHJvY2Vzc19nZW5lcmF0aW5nXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImdlbmVyYXRpbmdcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgbWVzc2FnZTogIWRhdGEuc3VjY2VzcyA/IGRhdGEub3V0cHV0LmVycm9yIDogbnVsbCxcbiAgICAgICAgICBzdGFnZTogZGF0YS5zdWNjZXNzID8gXCJnZW5lcmF0aW5nXCIgOiBcImVycm9yXCIsXG4gICAgICAgICAgY29kZTogZGF0YS5jb2RlLFxuICAgICAgICAgIHByb2dyZXNzX2RhdGE6IGRhdGEucHJvZ3Jlc3NfZGF0YSxcbiAgICAgICAgICBldGE6IGRhdGEuYXZlcmFnZV9kdXJhdGlvblxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiBkYXRhLnN1Y2Nlc3MgPyBkYXRhLm91dHB1dCA6IG51bGxcbiAgICAgIH07XG4gICAgY2FzZSBcInByb2Nlc3NfY29tcGxldGVkXCI6XG4gICAgICBpZiAoXCJlcnJvclwiIGluIGRhdGEub3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZGF0YS5vdXRwdXQuZXJyb3IsXG4gICAgICAgICAgICB2aXNpYmxlOiBkYXRhLm91dHB1dC52aXNpYmxlLFxuICAgICAgICAgICAgZHVyYXRpb246IGRhdGEub3V0cHV0LmR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGRhdGEuc3VjY2Vzc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29tcGxldGVcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgbWVzc2FnZTogIWRhdGEuc3VjY2VzcyA/IGRhdGEub3V0cHV0LmVycm9yIDogdm9pZCAwLFxuICAgICAgICAgIHN0YWdlOiBkYXRhLnN1Y2Nlc3MgPyBcImNvbXBsZXRlXCIgOiBcImVycm9yXCIsXG4gICAgICAgICAgY29kZTogZGF0YS5jb2RlLFxuICAgICAgICAgIHByb2dyZXNzX2RhdGE6IGRhdGEucHJvZ3Jlc3NfZGF0YSxcbiAgICAgICAgICBjaGFuZ2VkX3N0YXRlX2lkczogZGF0YS5zdWNjZXNzID8gZGF0YS5vdXRwdXQuY2hhbmdlZF9zdGF0ZV9pZHMgOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogZGF0YS5zdWNjZXNzID8gZGF0YS5vdXRwdXQgOiBudWxsXG4gICAgICB9O1xuICAgIGNhc2UgXCJwcm9jZXNzX3N0YXJ0c1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgc3RhZ2U6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICBzaXplOiBkYXRhLnJhbmssXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzLFxuICAgICAgICAgIGV0YTogZGF0YS5ldGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBcIm5vbmVcIiwgc3RhdHVzOiB7IHN0YWdlOiBcImVycm9yXCIsIHF1ZXVlIH0gfTtcbn1cbmNvbnN0IG1hcF9kYXRhX3RvX3BhcmFtcyA9IChkYXRhID0gW10sIGVuZHBvaW50X2luZm8pID0+IHtcbiAgY29uc3QgcGFyYW1ldGVycyA9IGVuZHBvaW50X2luZm8gPyBlbmRwb2ludF9pbmZvLnBhcmFtZXRlcnMgOiBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiBwYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFwiVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkIGZvciB0aGUgZW5kcG9pbnQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCByZXNvbHZlZF9kYXRhID0gW107XG4gIGNvbnN0IHByb3ZpZGVkX2tleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgcGFyYW1ldGVycy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShwYXJhbS5wYXJhbWV0ZXJfbmFtZSkpIHtcbiAgICAgIHJlc29sdmVkX2RhdGFbaW5kZXhdID0gZGF0YVtwYXJhbS5wYXJhbWV0ZXJfbmFtZV07XG4gICAgfSBlbHNlIGlmIChwYXJhbS5wYXJhbWV0ZXJfaGFzX2RlZmF1bHQpIHtcbiAgICAgIHJlc29sdmVkX2RhdGFbaW5kZXhdID0gcGFyYW0ucGFyYW1ldGVyX2RlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIHZhbHVlIHByb3ZpZGVkIGZvciByZXF1aXJlZCBwYXJhbWV0ZXI6ICR7cGFyYW0ucGFyYW1ldGVyX25hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICBwcm92aWRlZF9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1ldGVycy5zb21lKChwYXJhbSkgPT4gcGFyYW0ucGFyYW1ldGVyX25hbWUgPT09IGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhcmFtZXRlciBcXGAke2tleX1cXGAgaXMgbm90IGEgdmFsaWQga2V5d29yZCBhcmd1bWVudC4gUGxlYXNlIHJlZmVyIHRvIHRoZSBBUEkgZm9yIHVzYWdlLmBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmVzb2x2ZWRfZGF0YS5mb3JFYWNoKCh2YWx1ZSwgaWR4KSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgJiYgIXBhcmFtZXRlcnNbaWR4XS5wYXJhbWV0ZXJfaGFzX2RlZmF1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5vIHZhbHVlIHByb3ZpZGVkIGZvciByZXF1aXJlZCBwYXJhbWV0ZXI6ICR7cGFyYW1ldGVyc1tpZHhdLnBhcmFtZXRlcl9uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc29sdmVkX2RhdGE7XG59O1xuYXN5bmMgZnVuY3Rpb24gdmlld19hcGkoKSB7XG4gIGlmICh0aGlzLmFwaV9pbmZvKVxuICAgIHJldHVybiB0aGlzLmFwaV9pbmZvO1xuICBjb25zdCB7IGhmX3Rva2VuIH0gPSB0aGlzLm9wdGlvbnM7XG4gIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzO1xuICBjb25zdCBoZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICBpZiAoaGZfdG9rZW4pIHtcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7aGZfdG9rZW59YDtcbiAgfVxuICBpZiAoIWNvbmZpZykge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGxldCByZXNwb25zZTtcbiAgICBsZXQgYXBpX2luZm87XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmdyYWRpb19hcGlfaW5mbykge1xuICAgICAgYXBpX2luZm8gPSB3aW5kb3cuZ3JhZGlvX2FwaV9pbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VtaXZlcigoY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcudmVyc2lvbikgfHwgXCIyLjAuMFwiLCBcIjMuMzBcIikgPCAwKSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChTUEFDRV9GRVRDSEVSX1VSTCwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc2VyaWFsaXplOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdXJsID0gam9pbl91cmxzKGNvbmZpZy5yb290LCBBUElfSU5GT19VUkwpO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihCUk9LRU5fQ09OTkVDVElPTl9NU0cpO1xuICAgICAgfVxuICAgICAgYXBpX2luZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGlmIChcImFwaVwiIGluIGFwaV9pbmZvKSB7XG4gICAgICBhcGlfaW5mbyA9IGFwaV9pbmZvLmFwaTtcbiAgICB9XG4gICAgaWYgKGFwaV9pbmZvLm5hbWVkX2VuZHBvaW50c1tcIi9wcmVkaWN0XCJdICYmICFhcGlfaW5mby51bm5hbWVkX2VuZHBvaW50c1tcIjBcIl0pIHtcbiAgICAgIGFwaV9pbmZvLnVubmFtZWRfZW5kcG9pbnRzWzBdID0gYXBpX2luZm8ubmFtZWRfZW5kcG9pbnRzW1wiL3ByZWRpY3RcIl07XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1fYXBpX2luZm8oYXBpX2luZm8sIGNvbmZpZywgdGhpcy5hcGlfbWFwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFwiQ291bGQgbm90IGdldCBBUEkgaW5mby4gXCIgKyBlLm1lc3NhZ2U7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZF9maWxlcyhyb290X3VybCwgZmlsZXMsIHVwbG9hZF9pZCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKChfYSA9IHRoaXMgPT0gbnVsbCA/IHZvaWQgMCA6IHRoaXMub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3RoaXMub3B0aW9ucy5oZl90b2tlbn1gO1xuICB9XG4gIGNvbnN0IGNodW5rU2l6ZSA9IDFlMztcbiAgY29uc3QgdXBsb2FkUmVzcG9uc2VzID0gW107XG4gIGxldCByZXNwb25zZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmsgPSBmaWxlcy5zbGljZShpLCBpICsgY2h1bmtTaXplKTtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGNodW5rLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVzXCIsIGZpbGUpO1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cGxvYWRfdXJsID0gdXBsb2FkX2lkID8gYCR7cm9vdF91cmx9LyR7VVBMT0FEX1VSTH0/dXBsb2FkX2lkPSR7dXBsb2FkX2lkfWAgOiBgJHtyb290X3VybH0vJHtVUExPQURfVVJMfWA7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXBsb2FkX3VybCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoQlJPS0VOX0NPTk5FQ1RJT05fTVNHICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JfdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiB7IGVycm9yOiBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JfdGV4dH1gIH07XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICB1cGxvYWRSZXNwb25zZXMucHVzaCguLi5vdXRwdXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBmaWxlczogdXBsb2FkUmVzcG9uc2VzIH07XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWQoZmlsZV9kYXRhLCByb290X3VybCwgdXBsb2FkX2lkLCBtYXhfZmlsZV9zaXplKSB7XG4gIGxldCBmaWxlcyA9IChBcnJheS5pc0FycmF5KGZpbGVfZGF0YSkgPyBmaWxlX2RhdGEgOiBbZmlsZV9kYXRhXSkubWFwKFxuICAgIChmaWxlX2RhdGEyKSA9PiBmaWxlX2RhdGEyLmJsb2JcbiAgKTtcbiAgY29uc3Qgb3ZlcnNpemVkX2ZpbGVzID0gZmlsZXMuZmlsdGVyKFxuICAgIChmKSA9PiBmLnNpemUgPiAobWF4X2ZpbGVfc2l6ZSA/PyBJbmZpbml0eSlcbiAgKTtcbiAgaWYgKG92ZXJzaXplZF9maWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmlsZSBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIG9mICR7bWF4X2ZpbGVfc2l6ZX0gYnl0ZXM6ICR7b3ZlcnNpemVkX2ZpbGVzLm1hcCgoZikgPT4gZi5uYW1lKS5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGF3YWl0IHRoaXMudXBsb2FkX2ZpbGVzKHJvb3RfdXJsLCBmaWxlcywgdXBsb2FkX2lkKS50aGVuKFxuICAgICAgYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmZpbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZmlsZXMubWFwKChmLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZURhdGEoe1xuICAgICAgICAgICAgICAgIC4uLmZpbGVfZGF0YVtpXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBmLFxuICAgICAgICAgICAgICAgIHVybDogcm9vdF91cmwgKyBcIi9maWxlPVwiICsgZlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZV9maWxlcyhmaWxlcywgaXNfc3RyZWFtKSB7XG4gIHJldHVybiBmaWxlcy5tYXAoXG4gICAgKGYpID0+IG5ldyBGaWxlRGF0YSh7XG4gICAgICBwYXRoOiBmLm5hbWUsXG4gICAgICBvcmlnX25hbWU6IGYubmFtZSxcbiAgICAgIGJsb2I6IGYsXG4gICAgICBzaXplOiBmLnNpemUsXG4gICAgICBtaW1lX3R5cGU6IGYudHlwZSxcbiAgICAgIGlzX3N0cmVhbVxuICAgIH0pXG4gICk7XG59XG5jbGFzcyBGaWxlRGF0YSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXRoLFxuICAgIHVybCxcbiAgICBvcmlnX25hbWUsXG4gICAgc2l6ZSxcbiAgICBibG9iLFxuICAgIGlzX3N0cmVhbSxcbiAgICBtaW1lX3R5cGUsXG4gICAgYWx0X3RleHRcbiAgfSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXRoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1cmxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9yaWdfbmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2l6ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYmxvYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNfc3RyZWFtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW1lX3R5cGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFsdF90ZXh0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXRhXCIsIHsgX3R5cGU6IFwiZ3JhZGlvLkZpbGVEYXRhXCIgfSk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLm9yaWdfbmFtZSA9IG9yaWdfbmFtZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuYmxvYiA9IHVybCA/IHZvaWQgMCA6IGJsb2I7XG4gICAgdGhpcy5pc19zdHJlYW0gPSBpc19zdHJlYW07XG4gICAgdGhpcy5taW1lX3R5cGUgPSBtaW1lX3R5cGU7XG4gICAgdGhpcy5hbHRfdGV4dCA9IGFsdF90ZXh0O1xuICB9XG59XG5jbGFzcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IoY29tbWFuZCwgbWV0YSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0eXBlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb21tYW5kXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWxlRGF0YVwiKTtcbiAgICB0aGlzLnR5cGUgPSBcImNvbW1hbmRcIjtcbiAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbn1cbmNvbnN0IGlzX25vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbmZ1bmN0aW9uIHVwZGF0ZV9vYmplY3Qob2JqZWN0LCBuZXdWYWx1ZSwgc3RhY2spIHtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBrZXkyID0gc3RhY2suc2hpZnQoKTtcbiAgICBpZiAodHlwZW9mIGtleTIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleTIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXkyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgdHlwZVwiKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2V5ID0gc3RhY2suc2hpZnQoKTtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJudW1iZXJcIikge1xuICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgdHlwZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd2Fsa19hbmRfc3RvcmVfYmxvYnMoZGF0YSwgdHlwZSA9IHZvaWQgMCwgcGF0aCA9IFtdLCByb290ID0gZmFsc2UsIGVuZHBvaW50X2luZm8gPSB2b2lkIDApIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBsZXQgYmxvYl9yZWZzID0gW107XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBkYXRhLm1hcChhc3luYyAoXywgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgbmV3X3BhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgIG5ld19wYXRoLnB1c2goU3RyaW5nKGluZGV4KSk7XG4gICAgICAgIGNvbnN0IGFycmF5X3JlZnMgPSBhd2FpdCB3YWxrX2FuZF9zdG9yZV9ibG9icyhcbiAgICAgICAgICBkYXRhW2luZGV4XSxcbiAgICAgICAgICByb290ID8gKChfYSA9IGVuZHBvaW50X2luZm8gPT0gbnVsbCA/IHZvaWQgMCA6IGVuZHBvaW50X2luZm8ucGFyYW1ldGVyc1tpbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb21wb25lbnQpIHx8IHZvaWQgMCA6IHR5cGUsXG4gICAgICAgICAgbmV3X3BhdGgsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZW5kcG9pbnRfaW5mb1xuICAgICAgICApO1xuICAgICAgICBibG9iX3JlZnMgPSBibG9iX3JlZnMuY29uY2F0KGFycmF5X3JlZnMpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBibG9iX3JlZnM7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYmxvYjogbmV3IEJsb2IoW2RhdGFdKSxcbiAgICAgICAgdHlwZVxuICAgICAgfVxuICAgIF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCkge1xuICAgIGxldCBibG9iX3JlZnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkYXRhKSkge1xuICAgICAgY29uc3QgbmV3X3BhdGggPSBbLi4ucGF0aCwga2V5XTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgYmxvYl9yZWZzID0gYmxvYl9yZWZzLmNvbmNhdChcbiAgICAgICAgYXdhaXQgd2Fsa19hbmRfc3RvcmVfYmxvYnMoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIG5ld19wYXRoLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGVuZHBvaW50X2luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2JfcmVmcztcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBza2lwX3F1ZXVlKGlkLCBjb25maWcpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IGZuX3F1ZXVlID0gKF9iID0gKF9hID0gY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZGVwZW5kZW5jaWVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IucXVldWU7XG4gIGlmIChmbl9xdWV1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuICFmbl9xdWV1ZTtcbiAgfVxuICByZXR1cm4gIWNvbmZpZy5lbmFibGVfcXVldWU7XG59XG5mdW5jdGlvbiBwb3N0X21lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCBfcmVqKSA9PiB7XG4gICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICBjaGFubmVsLnBvcnQxLmNsb3NlKCk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfTtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbiwgW2NoYW5uZWwucG9ydDJdKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVfZmlsZShmaWxlX29yX3VybCkge1xuICBpZiAodHlwZW9mIGZpbGVfb3JfdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGZpbGVfb3JfdXJsLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IGZpbGVfb3JfdXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogZmlsZV9vcl91cmwsXG4gICAgICAgIHVybDogZmlsZV9vcl91cmwsXG4gICAgICAgIG9yaWdfbmFtZTogZmlsZV9vcl91cmwuc3BsaXQoXCIvXCIpLnBvcCgpID8/IFwidW5rbm93blwiLFxuICAgICAgICBtZXRhOiB7IF90eXBlOiBcImdyYWRpby5GaWxlRGF0YVwiIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc19ub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IENvbW1hbmQoXCJ1cGxvYWRfZmlsZVwiLCB7XG4gICAgICAgIHBhdGg6IGZpbGVfb3JfdXJsLFxuICAgICAgICBuYW1lOiBmaWxlX29yX3VybCxcbiAgICAgICAgb3JpZ19wYXRoOiBmaWxlX29yX3VybFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVfb3JfdXJsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgIHJldHVybiBuZXcgQmxvYihbZmlsZV9vcl91cmxdKTtcbiAgfSBlbHNlIGlmIChmaWxlX29yX3VybCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgQmxvYihbZmlsZV9vcl91cmxdKTtcbiAgfSBlbHNlIGlmIChmaWxlX29yX3VybCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gZmlsZV9vcl91cmw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiSW52YWxpZCBpbnB1dDogbXVzdCBiZSBhIFVSTCwgRmlsZSwgQmxvYiwgb3IgQnVmZmVyIG9iamVjdC5cIlxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlX3BheWxvYWQocmVzb2x2ZWRfcGF5bG9hZCwgZGVwZW5kZW5jeSwgY29tcG9uZW50cywgdHlwZSwgd2l0aF9udWxsX3N0YXRlID0gZmFsc2UpIHtcbiAgaWYgKHR5cGUgPT09IFwiaW5wdXRcIiAmJiAhd2l0aF9udWxsX3N0YXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBhdGguIENhbm5vdCBza2lwIHN0YXRlIGlucHV0cyBmb3IgaW5wdXQuXCIpO1xuICB9XG4gIGlmICh0eXBlID09PSBcIm91dHB1dFwiICYmIHdpdGhfbnVsbF9zdGF0ZSkge1xuICAgIHJldHVybiByZXNvbHZlZF9wYXlsb2FkO1xuICB9XG4gIGxldCB1cGRhdGVkX3BheWxvYWQgPSBbXTtcbiAgbGV0IHBheWxvYWRfaW5kZXggPSAwO1xuICBjb25zdCBkZXBzID0gdHlwZSA9PT0gXCJpbnB1dFwiID8gZGVwZW5kZW5jeS5pbnB1dHMgOiBkZXBlbmRlbmN5Lm91dHB1dHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGlucHV0X2lkID0gZGVwc1tpXTtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzLmZpbmQoKGMpID0+IGMuaWQgPT09IGlucHV0X2lkKTtcbiAgICBpZiAoKGNvbXBvbmVudCA9PSBudWxsID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcInN0YXRlXCIpIHtcbiAgICAgIGlmICh3aXRoX251bGxfc3RhdGUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkX3BheWxvYWQubGVuZ3RoID09PSBkZXBzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZWRfcGF5bG9hZFtwYXlsb2FkX2luZGV4XTtcbiAgICAgICAgICB1cGRhdGVkX3BheWxvYWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgcGF5bG9hZF9pbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZWRfcGF5bG9hZC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXlsb2FkX2luZGV4Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZWRfcGF5bG9hZFtwYXlsb2FkX2luZGV4XTtcbiAgICAgIHVwZGF0ZWRfcGF5bG9hZC5wdXNoKHZhbHVlKTtcbiAgICAgIHBheWxvYWRfaW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZWRfcGF5bG9hZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZV9ibG9iKGVuZHBvaW50LCBkYXRhLCBhcGlfaW5mbykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgYXdhaXQgcHJvY2Vzc19sb2NhbF9maWxlX2NvbW1hbmRzKHNlbGYsIGRhdGEpO1xuICBjb25zdCBibG9iUmVmcyA9IGF3YWl0IHdhbGtfYW5kX3N0b3JlX2Jsb2JzKFxuICAgIGRhdGEsXG4gICAgdm9pZCAwLFxuICAgIFtdLFxuICAgIHRydWUsXG4gICAgYXBpX2luZm9cbiAgKTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGJsb2JSZWZzLm1hcChhc3luYyAoeyBwYXRoLCBibG9iLCB0eXBlIH0pID0+IHtcbiAgICAgIGlmICghYmxvYilcbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgdHlwZSB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWxmLnVwbG9hZF9maWxlcyhlbmRwb2ludCwgW2Jsb2JdKTtcbiAgICAgIGNvbnN0IGZpbGVfdXJsID0gcmVzcG9uc2UuZmlsZXMgJiYgcmVzcG9uc2UuZmlsZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBmaWxlX3VybCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmFtZTogdHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYmxvYiBpbnN0YW5jZW9mIEZpbGUgPyBibG9iID09IG51bGwgPyB2b2lkIDAgOiBibG9iLm5hbWUgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgcmVzdWx0cy5mb3JFYWNoKCh7IHBhdGgsIGZpbGVfdXJsLCB0eXBlLCBuYW1lIH0pID0+IHtcbiAgICBpZiAodHlwZSA9PT0gXCJHYWxsZXJ5XCIpIHtcbiAgICAgIHVwZGF0ZV9vYmplY3QoZGF0YSwgZmlsZV91cmwsIHBhdGgpO1xuICAgIH0gZWxzZSBpZiAoZmlsZV91cmwpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZURhdGEoeyBwYXRoOiBmaWxlX3VybCwgb3JpZ19uYW1lOiBuYW1lIH0pO1xuICAgICAgdXBkYXRlX29iamVjdChkYXRhLCBmaWxlLCBwYXRoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NfbG9jYWxfZmlsZV9jb21tYW5kcyhjbGllbnQyLCBkYXRhKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJvb3QgPSAoKF9hID0gY2xpZW50Mi5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yb290KSB8fCAoKF9iID0gY2xpZW50Mi5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5yb290X3VybCk7XG4gIGlmICghcm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihST09UX1VSTF9FUlJPUl9NU0cpO1xuICB9XG4gIGF3YWl0IHJlY3Vyc2l2ZWx5X3Byb2Nlc3NfY29tbWFuZHMoY2xpZW50MiwgZGF0YSk7XG59XG5hc3luYyBmdW5jdGlvbiByZWN1cnNpdmVseV9wcm9jZXNzX2NvbW1hbmRzKGNsaWVudDIsIGRhdGEsIHBhdGggPSBbXSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGFba2V5XSBpbnN0YW5jZW9mIENvbW1hbmQpIHtcbiAgICAgIGF3YWl0IHByb2Nlc3Nfc2luZ2xlX2NvbW1hbmQoY2xpZW50MiwgZGF0YSwga2V5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2tleV0gPT09IFwib2JqZWN0XCIgJiYgZGF0YVtrZXldICE9PSBudWxsKSB7XG4gICAgICBhd2FpdCByZWN1cnNpdmVseV9wcm9jZXNzX2NvbW1hbmRzKGNsaWVudDIsIGRhdGFba2V5XSwgWy4uLnBhdGgsIGtleV0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc19zaW5nbGVfY29tbWFuZChjbGllbnQyLCBkYXRhLCBrZXkpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IGNtZF9pdGVtID0gZGF0YVtrZXldO1xuICBjb25zdCByb290ID0gKChfYSA9IGNsaWVudDIuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2Eucm9vdCkgfHwgKChfYiA9IGNsaWVudDIuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2Iucm9vdF91cmwpO1xuICBpZiAoIXJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoUk9PVF9VUkxfRVJST1JfTVNHKTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBmaWxlQnVmZmVyO1xuICAgIGxldCBmdWxsUGF0aDtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpIHtcbiAgICAgIGNvbnN0IGZzID0gYXdhaXQgaW1wb3J0KFwiZnMvcHJvbWlzZXNcIik7XG4gICAgICBjb25zdCBwYXRoID0gYXdhaXQgaW1wb3J0KFwicGF0aFwiKTtcbiAgICAgIGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIGNtZF9pdGVtLm1ldGEucGF0aCk7XG4gICAgICBmaWxlQnVmZmVyID0gYXdhaXQgZnMucmVhZEZpbGUoZnVsbFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTk9ERUpTX0ZTX0VSUk9SX01TRyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbZmlsZUJ1ZmZlcl0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudDIudXBsb2FkX2ZpbGVzKHJvb3QsIFtmaWxlXSk7XG4gICAgY29uc3QgZmlsZV91cmwgPSByZXNwb25zZS5maWxlcyAmJiByZXNwb25zZS5maWxlc1swXTtcbiAgICBpZiAoZmlsZV91cmwpIHtcbiAgICAgIGNvbnN0IGZpbGVEYXRhID0gbmV3IEZpbGVEYXRhKHtcbiAgICAgICAgcGF0aDogZmlsZV91cmwsXG4gICAgICAgIG9yaWdfbmFtZTogY21kX2l0ZW0ubWV0YS5uYW1lIHx8IFwiXCJcbiAgICAgIH0pO1xuICAgICAgZGF0YVtrZXldID0gZmlsZURhdGE7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoRklMRV9QUk9DRVNTSU5HX0VSUk9SX01TRywgZXJyb3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwb3N0X2RhdGEodXJsLCBib2R5LCBhZGRpdGlvbmFsX2hlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgaWYgKHRoaXMub3B0aW9ucy5oZl90b2tlbikge1xuICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0aGlzLm9wdGlvbnMuaGZfdG9rZW59YDtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBoZWFkZXJzOiB7IC4uLmhlYWRlcnMsIC4uLmFkZGl0aW9uYWxfaGVhZGVycyB9LFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW3sgZXJyb3I6IEJST0tFTl9DT05ORUNUSU9OX01TRyB9LCA1MDBdO1xuICB9XG4gIGxldCBvdXRwdXQ7XG4gIGxldCBzdGF0dXM7XG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dHB1dCA9IHsgZXJyb3I6IGBDb3VsZCBub3QgcGFyc2Ugc2VydmVyIHJlc3BvbnNlOiAke2V9YCB9O1xuICAgIHN0YXR1cyA9IDUwMDtcbiAgfVxuICByZXR1cm4gW291dHB1dCwgc3RhdHVzXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWRpY3QoZW5kcG9pbnQsIGRhdGEgPSB7fSkge1xuICBsZXQgZGF0YV9yZXR1cm5lZCA9IGZhbHNlO1xuICBsZXQgc3RhdHVzX2NvbXBsZXRlID0gZmFsc2U7XG4gIGlmICghdGhpcy5jb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBhcHAgY29uZmlnXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5kcG9pbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICB0aGlzLmNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gZW5kcG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRyaW1tZWRfZW5kcG9pbnQgPSBlbmRwb2ludC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgdGhpcy5jb25maWcuZGVwZW5kZW5jaWVzLmZpbmQoXG4gICAgICAoZGVwKSA9PiBkZXAuaWQgPT0gdGhpcy5hcGlfbWFwW3RyaW1tZWRfZW5kcG9pbnRdXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGFwcCA9IHRoaXMuc3VibWl0KGVuZHBvaW50LCBkYXRhLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiBhcHApIHtcbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgIGlmIChzdGF0dXNfY29tcGxldGUpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YV9yZXR1cm5lZCA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcInN0YXR1c1wiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YWdlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICBpZiAobWVzc2FnZS5zdGFnZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgc3RhdHVzX2NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZGF0YV9yZXR1cm5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja19zcGFjZV9zdGF0dXMoaWQsIHR5cGUsIHN0YXR1c19jYWxsYmFjaykge1xuICBsZXQgZW5kcG9pbnQgPSB0eXBlID09PSBcInN1YmRvbWFpblwiID8gYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy9ieS1zdWJkb21haW4vJHtpZH1gIDogYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy8ke2lkfWA7XG4gIGxldCByZXNwb25zZTtcbiAgbGV0IF9zdGF0dXM7XG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCk7XG4gICAgX3N0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBpZiAoX3N0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgcmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzdGF0dXNfY2FsbGJhY2soe1xuICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICBsb2FkX3N0YXR1czogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZTogU1BBQ0VfU1RBVFVTX0VSUk9SX01TRyxcbiAgICAgIGRldGFpbDogXCJOT1RfRk9VTkRcIlxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXJlc3BvbnNlIHx8IF9zdGF0dXMgIT09IDIwMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHtcbiAgICBydW50aW1lOiB7IHN0YWdlIH0sXG4gICAgaWQ6IHNwYWNlX25hbWVcbiAgfSA9IHJlc3BvbnNlO1xuICBzd2l0Y2ggKHN0YWdlKSB7XG4gICAgY2FzZSBcIlNUT1BQRURcIjpcbiAgICBjYXNlIFwiU0xFRVBJTkdcIjpcbiAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogXCJzbGVlcGluZ1wiLFxuICAgICAgICBsb2FkX3N0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiU3BhY2UgaXMgYXNsZWVwLiBXYWtpbmcgaXQgdXAuLi5cIixcbiAgICAgICAgZGV0YWlsOiBzdGFnZVxuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2hlY2tfc3BhY2Vfc3RhdHVzKGlkLCB0eXBlLCBzdGF0dXNfY2FsbGJhY2spO1xuICAgICAgfSwgMWUzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQQVVTRURcIjpcbiAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogXCJwYXVzZWRcIixcbiAgICAgICAgbG9hZF9zdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogXCJUaGlzIHNwYWNlIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgYXV0aG9yLiBJZiB5b3Ugd291bGQgbGlrZSB0byB0cnkgdGhpcyBkZW1vLCBjb25zaWRlciBkdXBsaWNhdGluZyB0aGUgc3BhY2UuXCIsXG4gICAgICAgIGRldGFpbDogc3RhZ2UsXG4gICAgICAgIGRpc2N1c3Npb25zX2VuYWJsZWQ6IGF3YWl0IGRpc2N1c3Npb25zX2VuYWJsZWQoc3BhY2VfbmFtZSlcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlJVTk5JTkdcIjpcbiAgICBjYXNlIFwiUlVOTklOR19CVUlMRElOR1wiOlxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHtcbiAgICAgICAgc3RhdHVzOiBcInJ1bm5pbmdcIixcbiAgICAgICAgbG9hZF9zdGF0dXM6IFwiY29tcGxldGVcIixcbiAgICAgICAgbWVzc2FnZTogXCJTcGFjZSBpcyBydW5uaW5nLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJCVUlMRElOR1wiOlxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHtcbiAgICAgICAgc3RhdHVzOiBcImJ1aWxkaW5nXCIsXG4gICAgICAgIGxvYWRfc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgbWVzc2FnZTogXCJTcGFjZSBpcyBidWlsZGluZy4uLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjaGVja19zcGFjZV9zdGF0dXMoaWQsIHR5cGUsIHN0YXR1c19jYWxsYmFjayk7XG4gICAgICB9LCAxZTMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkFQUF9TVEFSVElOR1wiOlxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHtcbiAgICAgICAgc3RhdHVzOiBcInN0YXJ0aW5nXCIsXG4gICAgICAgIGxvYWRfc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgbWVzc2FnZTogXCJTcGFjZSBpcyBzdGFydGluZy4uLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjaGVja19zcGFjZV9zdGF0dXMoaWQsIHR5cGUsIHN0YXR1c19jYWxsYmFjayk7XG4gICAgICB9LCAxZTMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogXCJzcGFjZV9lcnJvclwiLFxuICAgICAgICBsb2FkX3N0YXR1czogXCJlcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBcIlRoaXMgc3BhY2UgaXMgZXhwZXJpZW5jaW5nIGFuIGlzc3VlLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlLFxuICAgICAgICBkaXNjdXNzaW9uc19lbmFibGVkOiBhd2FpdCBkaXNjdXNzaW9uc19lbmFibGVkKHNwYWNlX25hbWUpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5jb25zdCBjaGVja19hbmRfd2FrZV9zcGFjZSA9IGFzeW5jIChzcGFjZV9pZCwgc3RhdHVzX2NhbGxiYWNrKSA9PiB7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgbWF4X3JldHJpZXMgPSAxMjtcbiAgY29uc3QgY2hlY2tfaW50ZXJ2YWwgPSA1ZTM7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNoZWNrX3NwYWNlX3N0YXR1cyhcbiAgICAgIHNwYWNlX2lkLFxuICAgICAgUkVfU1BBQ0VfTkFNRS50ZXN0KHNwYWNlX2lkKSA/IFwic3BhY2VfbmFtZVwiIDogXCJzdWJkb21haW5cIixcbiAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgc3RhdHVzX2NhbGxiYWNrKHN0YXR1cyk7XG4gICAgICAgIGlmIChzdGF0dXMuc3RhdHVzID09PSBcInJ1bm5pbmdcIikge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMuc3RhdHVzID09PSBcImVycm9yXCIgfHwgc3RhdHVzLnN0YXR1cyA9PT0gXCJwYXVzZWRcIiB8fCBzdGF0dXMuc3RhdHVzID09PSBcInNwYWNlX2Vycm9yXCIpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzLnN0YXR1cyA9PT0gXCJzbGVlcGluZ1wiIHx8IHN0YXR1cy5zdGF0dXMgPT09IFwiYnVpbGRpbmdcIikge1xuICAgICAgICAgIGlmIChyZXRyaWVzIDwgbWF4X3JldHJpZXMpIHtcbiAgICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjaGVja19hbmRfd2FrZV9zcGFjZShzcGFjZV9pZCwgc3RhdHVzX2NhbGxiYWNrKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSwgY2hlY2tfaW50ZXJ2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59O1xuY29uc3QgUkVfRElTQUJMRURfRElTQ1VTU0lPTiA9IC9eKD89W15dKlxcYltkRF1pc2N1c3Npb25zezAsMX1cXGIpKD89W15dKlxcYltkRF1pc2FibGVkXFxiKVteXSokLztcbmFzeW5jIGZ1bmN0aW9uIGRpc2N1c3Npb25zX2VuYWJsZWQoc3BhY2VfaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvc3BhY2VzLyR7c3BhY2VfaWR9L2Rpc2N1c3Npb25zYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZXJyb3IgPSByLmhlYWRlcnMuZ2V0KFwieC1lcnJvci1tZXNzYWdlXCIpO1xuICAgIGlmICghci5vayB8fCBlcnJvciAmJiBSRV9ESVNBQkxFRF9ESVNDVVNTSU9OLnRlc3QoZXJyb3IpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRfc3BhY2VfaGFyZHdhcmUoc3BhY2VfaWQsIGhmX3Rva2VuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9zcGFjZXMvJHtzcGFjZV9pZH0vJHtSVU5USU1FX1VSTH1gLFxuICAgICAgeyBoZWFkZXJzIH1cbiAgICApO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGFjZSBoYXJkd2FyZSBjb3VsZCBub3QgYmUgb2J0YWluZWQuXCIpO1xuICAgIGNvbnN0IHsgaGFyZHdhcmUgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGhhcmR3YXJlLmN1cnJlbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0X3NwYWNlX3RpbWVvdXQoc3BhY2VfaWQsIHRpbWVvdXQsIGhmX3Rva2VuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gIH1cbiAgY29uc3QgYm9keSA9IHtcbiAgICBzZWNvbmRzOiB0aW1lb3V0XG4gIH07XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvc3BhY2VzLyR7c3BhY2VfaWR9LyR7U0xFRVBUSU1FX1VSTH1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGQgbm90IHNldCBzbGVlcCB0aW1lb3V0IG9uIGR1cGxpY2F0ZWQgU3BhY2UuIFBsZWFzZSB2aXNpdCAqQUREIEhGIExJTksgVE8gU0VUVElOR1MqIHRvIHNldCBhIHRpbWVvdXQgbWFudWFsbHkgdG8gcmVkdWNlIGJpbGxpbmcgY2hhcmdlcy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICB9XG59XG5jb25zdCBoYXJkd2FyZV90eXBlcyA9IFtcbiAgXCJjcHUtYmFzaWNcIixcbiAgXCJjcHUtdXBncmFkZVwiLFxuICBcImNwdS14bFwiLFxuICBcInQ0LXNtYWxsXCIsXG4gIFwidDQtbWVkaXVtXCIsXG4gIFwiYTEwZy1zbWFsbFwiLFxuICBcImExMGctbGFyZ2VcIixcbiAgXCJhMTBnLWxhcmdleDJcIixcbiAgXCJhMTBnLWxhcmdleDRcIixcbiAgXCJhMTAwLWxhcmdlXCIsXG4gIFwiemVyby1hMTBnXCIsXG4gIFwiaDEwMFwiLFxuICBcImgxMDB4OFwiXG5dO1xuYXN5bmMgZnVuY3Rpb24gZHVwbGljYXRlKGFwcF9yZWZlcmVuY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoZl90b2tlbiwgcHJpdmF0ZTogX3ByaXZhdGUsIGhhcmR3YXJlLCB0aW1lb3V0LCBhdXRoIH0gPSBvcHRpb25zO1xuICBpZiAoaGFyZHdhcmUgJiYgIWhhcmR3YXJlX3R5cGVzLmluY2x1ZGVzKGhhcmR3YXJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGhhcmR3YXJlIHR5cGUgcHJvdmlkZWQuIFZhbGlkIHR5cGVzIGFyZTogJHtoYXJkd2FyZV90eXBlcy5tYXAoKHYpID0+IGBcIiR7dn1cImApLmpvaW4oXCIsXCIpfS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IGh0dHBfcHJvdG9jb2wsIGhvc3QgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgYXBwX3JlZmVyZW5jZSxcbiAgICBoZl90b2tlblxuICApO1xuICBsZXQgY29va2llcyA9IG51bGw7XG4gIGlmIChhdXRoKSB7XG4gICAgY29uc3QgY29va2llX2hlYWRlciA9IGF3YWl0IGdldF9jb29raWVfaGVhZGVyKFxuICAgICAgaHR0cF9wcm90b2NvbCxcbiAgICAgIGhvc3QsXG4gICAgICBhdXRoLFxuICAgICAgZmV0Y2hcbiAgICApO1xuICAgIGlmIChjb29raWVfaGVhZGVyKVxuICAgICAgY29va2llcyA9IHBhcnNlX2FuZF9zZXRfY29va2llcyhjb29raWVfaGVhZGVyKTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtoZl90b2tlbn1gLFxuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmNvb2tpZXMgPyB7IENvb2tpZTogY29va2llcy5qb2luKFwiOyBcIikgfSA6IHt9XG4gIH07XG4gIGNvbnN0IHVzZXIgPSAoYXdhaXQgKGF3YWl0IGZldGNoKGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS93aG9hbWktdjJgLCB7XG4gICAgaGVhZGVyc1xuICB9KSkuanNvbigpKS5uYW1lO1xuICBjb25zdCBzcGFjZV9uYW1lID0gYXBwX3JlZmVyZW5jZS5zcGxpdChcIi9cIilbMV07XG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgcmVwb3NpdG9yeTogYCR7dXNlcn0vJHtzcGFjZV9uYW1lfWBcbiAgfTtcbiAgaWYgKF9wcml2YXRlKSB7XG4gICAgYm9keS5wcml2YXRlID0gdHJ1ZTtcbiAgfVxuICBsZXQgb3JpZ2luYWxfaGFyZHdhcmU7XG4gIHRyeSB7XG4gICAgaWYgKCFoYXJkd2FyZSkge1xuICAgICAgb3JpZ2luYWxfaGFyZHdhcmUgPSBhd2FpdCBnZXRfc3BhY2VfaGFyZHdhcmUoYXBwX3JlZmVyZW5jZSwgaGZfdG9rZW4pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IEVycm9yKFNQQUNFX01FVEFEQVRBX0VSUk9SX01TRyArIGUubWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgcmVxdWVzdGVkX2hhcmR3YXJlID0gaGFyZHdhcmUgfHwgb3JpZ2luYWxfaGFyZHdhcmUgfHwgXCJjcHUtYmFzaWNcIjtcbiAgYm9keS5oYXJkd2FyZSA9IHJlcXVlc3RlZF9oYXJkd2FyZTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy8ke2FwcF9yZWZlcmVuY2V9L2R1cGxpY2F0ZWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNsaWVudDIgPSBhd2FpdCBDbGllbnQuY29ubmVjdChgJHt1c2VyfS8ke3NwYWNlX25hbWV9YCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBjbGllbnQyO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IENsaWVudCBpbnN0YW5jZTpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGR1cGxpY2F0ZWRfc3BhY2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgYXdhaXQgc2V0X3NwYWNlX3RpbWVvdXQoYCR7dXNlcn0vJHtzcGFjZV9uYW1lfWAsIHRpbWVvdXQgfHwgMzAwLCBoZl90b2tlbik7XG4gICAgcmV0dXJuIGF3YWl0IENsaWVudC5jb25uZWN0KFxuICAgICAgZ2V0X3NwYWNlX3JlZmVyZW5jZShkdXBsaWNhdGVkX3NwYWNlLnVybCksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0X3NwYWNlX3JlZmVyZW5jZSh1cmwpIHtcbiAgY29uc3QgcmVnZXggPSAvaHR0cHM6XFwvXFwvaHVnZ2luZ2ZhY2UuY29cXC9zcGFjZXNcXC8oW14vXStcXC9bXi9dKykvO1xuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdleCk7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxufVxuY2xhc3MgVGV4dExpbmVTdHJlYW0gZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICAvKiogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZS4gKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgYWxsb3dDUjogZmFsc2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zZm9ybTogKGNoYXJzLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNoYXJzID0gX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50TGluZSkgKyBjaGFycztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBsZkluZGV4ID0gY2hhcnMuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBjckluZGV4ID0gb3B0aW9ucy5hbGxvd0NSID8gY2hhcnMuaW5kZXhPZihcIlxcclwiKSA6IC0xO1xuICAgICAgICAgIGlmIChjckluZGV4ICE9PSAtMSAmJiBjckluZGV4ICE9PSBjaGFycy5sZW5ndGggLSAxICYmIChsZkluZGV4ID09PSAtMSB8fCBsZkluZGV4IC0gMSA+IGNySW5kZXgpKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2hhcnMuc2xpY2UoMCwgY3JJbmRleCkpO1xuICAgICAgICAgICAgY2hhcnMgPSBjaGFycy5zbGljZShjckluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxmSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjaGFyc1tsZkluZGV4IC0gMV0gPT09IFwiXFxyXCIgPyBsZkluZGV4IC0gMSA6IGxmSW5kZXg7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNoYXJzLnNsaWNlKDAsIGVuZEluZGV4KSk7XG4gICAgICAgICAgY2hhcnMgPSBjaGFycy5zbGljZShsZkluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jdXJyZW50TGluZSwgY2hhcnMpO1xuICAgICAgfSxcbiAgICAgIGZsdXNoOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50TGluZSkgPT09IFwiXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50TGluZSA9IG9wdGlvbnMuYWxsb3dDUiAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2N1cnJlbnRMaW5lKS5lbmRzV2l0aChcIlxcclwiKSA/IF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VycmVudExpbmUpLnNsaWNlKDAsIC0xKSA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VycmVudExpbmUpO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY3VycmVudExpbmUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY3VycmVudExpbmUsIFwiXCIpO1xuICB9XG59XG5fY3VycmVudExpbmUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc3RyZWFtJDEoaW5wdXQpIHtcbiAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXJTdHJlYW0oKTtcbiAgbGV0IHNwbGl0MiA9IG5ldyBUZXh0TGluZVN0cmVhbSh7IGFsbG93Q1I6IHRydWUgfSk7XG4gIHJldHVybiBpbnB1dC5waXBlVGhyb3VnaChkZWNvZGVyKS5waXBlVGhyb3VnaChzcGxpdDIpO1xufVxuZnVuY3Rpb24gc3BsaXQoaW5wdXQpIHtcbiAgbGV0IHJneCA9IC9bOl1cXHMqLztcbiAgbGV0IG1hdGNoID0gcmd4LmV4ZWMoaW5wdXQpO1xuICBsZXQgaWR4ID0gbWF0Y2ggJiYgbWF0Y2guaW5kZXg7XG4gIGlmIChpZHgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXQuc3Vic3RyaW5nKDAsIGlkeCksXG4gICAgICBpbnB1dC5zdWJzdHJpbmcoaWR4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxuICAgIF07XG4gIH1cbn1cbmZ1bmN0aW9uIGZhbGxiYWNrKGhlYWRlcnMsIGtleSwgdmFsdWUpIHtcbiAgbGV0IHRtcCA9IGhlYWRlcnMuZ2V0KGtleSk7XG4gIGlmICghdG1wKVxuICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xufVxuYXN5bmMgZnVuY3Rpb24qIGV2ZW50cyhyZXMsIHNpZ25hbCkge1xuICBpZiAoIXJlcy5ib2R5KVxuICAgIHJldHVybjtcbiAgbGV0IGl0ZXIgPSBzdHJlYW0kMShyZXMuYm9keSk7XG4gIGxldCBsaW5lLCByZWFkZXIgPSBpdGVyLmdldFJlYWRlcigpO1xuICBsZXQgZXZlbnQ7XG4gIGZvciAoOyA7ICkge1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWFkZXIuY2FuY2VsKCk7XG4gICAgfVxuICAgIGxpbmUgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChsaW5lLmRvbmUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFsaW5lLnZhbHVlKSB7XG4gICAgICBpZiAoZXZlbnQpXG4gICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgZXZlbnQgPSB2b2lkIDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IFtmaWVsZCwgdmFsdWVdID0gc3BsaXQobGluZS52YWx1ZSkgfHwgW107XG4gICAgaWYgKCFmaWVsZClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChmaWVsZCA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIGV2ZW50IHx8IChldmVudCA9IHt9KTtcbiAgICAgIGV2ZW50W2ZpZWxkXSA9IGV2ZW50W2ZpZWxkXSA/IGV2ZW50W2ZpZWxkXSArIFwiXFxuXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmllbGQgPT09IFwiZXZlbnRcIikge1xuICAgICAgZXZlbnQgfHwgKGV2ZW50ID0ge30pO1xuICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gXCJpZFwiKSB7XG4gICAgICBldmVudCB8fCAoZXZlbnQgPSB7fSk7XG4gICAgICBldmVudFtmaWVsZF0gPSArdmFsdWUgfHwgdmFsdWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gXCJyZXRyeVwiKSB7XG4gICAgICBldmVudCB8fCAoZXZlbnQgPSB7fSk7XG4gICAgICBldmVudFtmaWVsZF0gPSArdmFsdWUgfHwgdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtKGlucHV0LCBpbml0KSB7XG4gIGxldCByZXEgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gIGZhbGxiYWNrKHJlcS5oZWFkZXJzLCBcIkFjY2VwdFwiLCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICBmYWxsYmFjayhyZXEuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICBsZXQgciA9IGF3YWl0IGZldGNoKHJlcSk7XG4gIGlmICghci5vaylcbiAgICB0aHJvdyByO1xuICByZXR1cm4gZXZlbnRzKHIsIHJlcS5zaWduYWwpO1xufVxuYXN5bmMgZnVuY3Rpb24gb3Blbl9zdHJlYW0oKSB7XG4gIGxldCB7XG4gICAgZXZlbnRfY2FsbGJhY2tzLFxuICAgIHVuY2xvc2VkX2V2ZW50cyxcbiAgICBwZW5kaW5nX3N0cmVhbV9tZXNzYWdlcyxcbiAgICBzdHJlYW1fc3RhdHVzLFxuICAgIGNvbmZpZyxcbiAgICBqd3RcbiAgfSA9IHRoaXM7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGFwcCBjb25maWdcIik7XG4gIH1cbiAgc3RyZWFtX3N0YXR1cy5vcGVuID0gdHJ1ZTtcbiAgbGV0IHN0cmVhbTIgPSBudWxsO1xuICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgc2Vzc2lvbl9oYXNoOiB0aGlzLnNlc3Npb25faGFzaFxuICB9KS50b1N0cmluZygpO1xuICBsZXQgdXJsID0gbmV3IFVSTChgJHtjb25maWcucm9vdH0vcXVldWUvZGF0YT8ke3BhcmFtc31gKTtcbiAgaWYgKGp3dCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX19zaWduXCIsIGp3dCk7XG4gIH1cbiAgc3RyZWFtMiA9IHRoaXMuc3RyZWFtKHVybCk7XG4gIGlmICghc3RyZWFtMikge1xuICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBjb25uZWN0IHRvIFNTRSBlbmRwb2ludDogXCIgKyB1cmwudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0cmVhbTIub25tZXNzYWdlID0gYXN5bmMgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsZXQgX2RhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIGlmIChfZGF0YS5tc2cgPT09IFwiY2xvc2Vfc3RyZWFtXCIpIHtcbiAgICAgIGNsb3NlX3N0cmVhbShzdHJlYW1fc3RhdHVzLCB0aGF0LmFib3J0X2NvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudF9pZCA9IF9kYXRhLmV2ZW50X2lkO1xuICAgIGlmICghZXZlbnRfaWQpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBPYmplY3Qua2V5cyhldmVudF9jYWxsYmFja3MpLm1hcChcbiAgICAgICAgICAoZXZlbnRfaWQyKSA9PiBldmVudF9jYWxsYmFja3NbZXZlbnRfaWQyXShfZGF0YSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50X2NhbGxiYWNrc1tldmVudF9pZF0gJiYgY29uZmlnKSB7XG4gICAgICBpZiAoX2RhdGEubXNnID09PSBcInByb2Nlc3NfY29tcGxldGVkXCIgJiYgW1wic3NlXCIsIFwic3NlX3YxXCIsIFwic3NlX3YyXCIsIFwic3NlX3YyLjFcIiwgXCJzc2VfdjNcIl0uaW5jbHVkZXMoXG4gICAgICAgIGNvbmZpZy5wcm90b2NvbFxuICAgICAgKSkge1xuICAgICAgICB1bmNsb3NlZF9ldmVudHMuZGVsZXRlKGV2ZW50X2lkKTtcbiAgICAgIH1cbiAgICAgIGxldCBmbjIgPSBldmVudF9jYWxsYmFja3NbZXZlbnRfaWRdO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4yLCAwLCBfZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbjIoX2RhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzW2V2ZW50X2lkXSkge1xuICAgICAgICBwZW5kaW5nX3N0cmVhbV9tZXNzYWdlc1tldmVudF9pZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzW2V2ZW50X2lkXS5wdXNoKF9kYXRhKTtcbiAgICB9XG4gIH07XG4gIHN0cmVhbTIub25lcnJvciA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmtleXMoZXZlbnRfY2FsbGJhY2tzKS5tYXAoXG4gICAgICAgIChldmVudF9pZCkgPT4gZXZlbnRfY2FsbGJhY2tzW2V2ZW50X2lkXSh7XG4gICAgICAgICAgbXNnOiBcInVuZXhwZWN0ZWRfZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBCUk9LRU5fQ09OTkVDVElPTl9NU0dcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gY2xvc2Vfc3RyZWFtKHN0cmVhbV9zdGF0dXMsIGFib3J0X2NvbnRyb2xsZXIpIHtcbiAgaWYgKHN0cmVhbV9zdGF0dXMpIHtcbiAgICBzdHJlYW1fc3RhdHVzLm9wZW4gPSBmYWxzZTtcbiAgICBhYm9ydF9jb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydF9jb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5X2RpZmZfc3RyZWFtKHBlbmRpbmdfZGlmZl9zdHJlYW1zLCBldmVudF9pZCwgZGF0YSkge1xuICBsZXQgaXNfZmlyc3RfZ2VuZXJhdGlvbiA9ICFwZW5kaW5nX2RpZmZfc3RyZWFtc1tldmVudF9pZF07XG4gIGlmIChpc19maXJzdF9nZW5lcmF0aW9uKSB7XG4gICAgcGVuZGluZ19kaWZmX3N0cmVhbXNbZXZlbnRfaWRdID0gW107XG4gICAgZGF0YS5kYXRhLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICBwZW5kaW5nX2RpZmZfc3RyZWFtc1tldmVudF9pZF1baV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmRhdGEuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgIGxldCBuZXdfZGF0YSA9IGFwcGx5X2RpZmYocGVuZGluZ19kaWZmX3N0cmVhbXNbZXZlbnRfaWRdW2ldLCB2YWx1ZSk7XG4gICAgICBwZW5kaW5nX2RpZmZfc3RyZWFtc1tldmVudF9pZF1baV0gPSBuZXdfZGF0YTtcbiAgICAgIGRhdGEuZGF0YVtpXSA9IG5ld19kYXRhO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhcHBseV9kaWZmKG9iaiwgZGlmZikge1xuICBkaWZmLmZvckVhY2goKFthY3Rpb24sIHBhdGgsIHZhbHVlXSkgPT4ge1xuICAgIG9iaiA9IGFwcGx5X2VkaXQob2JqLCBwYXRoLCBhY3Rpb24sIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBhcHBseV9lZGl0KHRhcmdldCwgcGF0aCwgYWN0aW9uLCB2YWx1ZSkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoYWN0aW9uID09PSBcInJlcGxhY2VcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcImFwcGVuZFwiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0ICsgdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aW9uOiAke2FjdGlvbn1gKTtcbiAgfVxuICBsZXQgY3VycmVudCA9IHRhcmdldDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhbaV1dO1xuICB9XG4gIGNvbnN0IGxhc3RfcGF0aCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgY3VycmVudFtsYXN0X3BhdGhdID0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCI6XG4gICAgICBjdXJyZW50W2xhc3RfcGF0aF0gKz0gdmFsdWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYWRkXCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShOdW1iZXIobGFzdF9wYXRoKSwgMCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFtsYXN0X3BhdGhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShOdW1iZXIobGFzdF9wYXRoKSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgY3VycmVudFtsYXN0X3BhdGhdO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb246ICR7YWN0aW9ufWApO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiByZWFkYWJsZV9zdHJlYW0oaW5wdXQsIGluaXQgPSB7fSkge1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfSxcbiAgICBvbmVycm9yOiBudWxsLFxuICAgIG9ubWVzc2FnZTogbnVsbCxcbiAgICBvbm9wZW46IG51bGwsXG4gICAgcmVhZHlTdGF0ZTogMCxcbiAgICB1cmw6IGlucHV0LnRvU3RyaW5nKCksXG4gICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICBDT05ORUNUSU5HOiAwLFxuICAgIE9QRU46IDEsXG4gICAgQ0xPU0VEOiAyLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFdmVudDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gIH07XG4gIHN0cmVhbShpbnB1dCwgaW5pdCkudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgaW5zdGFuY2UucmVhZHlTdGF0ZSA9IGluc3RhbmNlLk9QRU47XG4gICAgdHJ5IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzKSB7XG4gICAgICAgIGluc3RhbmNlLm9ubWVzc2FnZSAmJiBpbnN0YW5jZS5vbm1lc3NhZ2UoY2h1bmspO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UucmVhZHlTdGF0ZSA9IGluc3RhbmNlLkNMT1NFRDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbnN0YW5jZS5vbmVycm9yICYmIGluc3RhbmNlLm9uZXJyb3IoZSk7XG4gICAgICBpbnN0YW5jZS5yZWFkeVN0YXRlID0gaW5zdGFuY2UuQ0xPU0VEO1xuICAgIH1cbiAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIGluc3RhbmNlLm9uZXJyb3IgJiYgaW5zdGFuY2Uub25lcnJvcihlKTtcbiAgICBpbnN0YW5jZS5yZWFkeVN0YXRlID0gaW5zdGFuY2UuQ0xPU0VEO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gc3VibWl0KGVuZHBvaW50LCBkYXRhID0ge30sIGV2ZW50X2RhdGEsIHRyaWdnZXJfaWQsIGFsbF9ldmVudHMpIHtcbiAgdmFyIF9hO1xuICB0cnkge1xuICAgIGxldCBmaXJlX2V2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChhbGxfZXZlbnRzIHx8IGV2ZW50c190b19wdWJsaXNoW2V2ZW50LnR5cGVdKSB7XG4gICAgICAgIHB1c2hfZXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIGNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChyZXNvbHZlcnMubGVuZ3RoID4gMClcbiAgICAgICAgcmVzb2x2ZXJzLnNoaWZ0KCkoe1xuICAgICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LCBwdXNoID0gZnVuY3Rpb24oZGF0YTIpIHtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocmVzb2x2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzb2x2ZXJzLnNoaWZ0KCkoZGF0YTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goZGF0YTIpO1xuICAgICAgfVxuICAgIH0sIHB1c2hfZXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgcHVzaCh0aGVuYWJsZV9yZWplY3QoZXJyb3IpKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfSwgcHVzaF9ldmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBwdXNoKHsgdmFsdWU6IGV2ZW50LCBkb25lOiBmYWxzZSB9KTtcbiAgICB9LCBuZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWVzLnNoaWZ0KCkpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB2YWx1ZTogdm9pZCAwLCBkb25lOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlcnMucHVzaChyZXNvbHZlKSk7XG4gICAgfTtcbiAgICBjb25zdCB7IGhmX3Rva2VuIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgZmV0Y2g6IGZldGNoMixcbiAgICAgIGFwcF9yZWZlcmVuY2UsXG4gICAgICBjb25maWcsXG4gICAgICBzZXNzaW9uX2hhc2gsXG4gICAgICBhcGlfaW5mbyxcbiAgICAgIGFwaV9tYXAsXG4gICAgICBzdHJlYW1fc3RhdHVzLFxuICAgICAgcGVuZGluZ19zdHJlYW1fbWVzc2FnZXMsXG4gICAgICBwZW5kaW5nX2RpZmZfc3RyZWFtcyxcbiAgICAgIGV2ZW50X2NhbGxiYWNrcyxcbiAgICAgIHVuY2xvc2VkX2V2ZW50cyxcbiAgICAgIHBvc3RfZGF0YTogcG9zdF9kYXRhMixcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICBpZiAoIWFwaV9pbmZvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gQVBJIGZvdW5kXCIpO1xuICAgIGlmICghY29uZmlnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgYXBwIGNvbmZpZ1wiKTtcbiAgICBsZXQgeyBmbl9pbmRleCwgZW5kcG9pbnRfaW5mbywgZGVwZW5kZW5jeSB9ID0gZ2V0X2VuZHBvaW50X2luZm8oXG4gICAgICBhcGlfaW5mbyxcbiAgICAgIGVuZHBvaW50LFxuICAgICAgYXBpX21hcCxcbiAgICAgIGNvbmZpZ1xuICAgICk7XG4gICAgbGV0IHJlc29sdmVkX2RhdGEgPSBtYXBfZGF0YV90b19wYXJhbXMoZGF0YSwgZW5kcG9pbnRfaW5mbyk7XG4gICAgbGV0IHdlYnNvY2tldDtcbiAgICBsZXQgc3RyZWFtMjtcbiAgICBsZXQgcHJvdG9jb2wgPSBjb25maWcucHJvdG9jb2wgPz8gXCJ3c1wiO1xuICAgIGNvbnN0IF9lbmRwb2ludCA9IHR5cGVvZiBlbmRwb2ludCA9PT0gXCJudW1iZXJcIiA/IFwiL3ByZWRpY3RcIiA6IGVuZHBvaW50O1xuICAgIGxldCBwYXlsb2FkO1xuICAgIGxldCBldmVudF9pZCA9IG51bGw7XG4gICAgbGV0IGNvbXBsZXRlID0gZmFsc2U7XG4gICAgbGV0IGxhc3Rfc3RhdHVzID0ge307XG4gICAgbGV0IHVybF9wYXJhbXMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgY29uc3QgZXZlbnRzX3RvX3B1Ymxpc2ggPSAoKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ldmVudHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWR1Y2UoXG4gICAgICAoYWNjLCBldmVudCkgPT4ge1xuICAgICAgICBhY2NbZXZlbnRdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICkpIHx8IHt9O1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGNvbnN0IF9zdGF0dXMgPSB7XG4gICAgICAgIHN0YWdlOiBcImNvbXBsZXRlXCIsXG4gICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgIH07XG4gICAgICBjb21wbGV0ZSA9IF9zdGF0dXM7XG4gICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgLi4uX3N0YXR1cyxcbiAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgZm5faW5kZXhcbiAgICAgIH0pO1xuICAgICAgbGV0IHJlc2V0X3JlcXVlc3QgPSB7fTtcbiAgICAgIGxldCBjYW5jZWxfcmVxdWVzdCA9IHt9O1xuICAgICAgaWYgKHByb3RvY29sID09PSBcIndzXCIpIHtcbiAgICAgICAgaWYgKHdlYnNvY2tldCAmJiB3ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgICAgIHdlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXNldF9yZXF1ZXN0ID0geyBmbl9pbmRleCwgc2Vzc2lvbl9oYXNoIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZV9zdHJlYW0oc3RyZWFtX3N0YXR1cywgdGhhdC5hYm9ydF9jb250cm9sbGVyKTtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgcmVzZXRfcmVxdWVzdCA9IHsgZXZlbnRfaWQgfTtcbiAgICAgICAgY2FuY2VsX3JlcXVlc3QgPSB7IGV2ZW50X2lkLCBzZXNzaW9uX2hhc2gsIGZuX2luZGV4IH07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGFwcCBjb25maWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZXZlbnRfaWRcIiBpbiBjYW5jZWxfcmVxdWVzdCkge1xuICAgICAgICAgIGF3YWl0IGZldGNoMihgJHtjb25maWcucm9vdH0vY2FuY2VsYCwge1xuICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNhbmNlbF9yZXF1ZXN0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZldGNoMihgJHtjb25maWcucm9vdH0vcmVzZXRgLCB7XG4gICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVzZXRfcmVxdWVzdClcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgL3Jlc2V0YCBlbmRwb2ludCBjb3VsZCBub3QgYmUgY2FsbGVkLiBTdWJzZXF1ZW50IGVuZHBvaW50IHJlc3VsdHMgbWF5IGJlIHVucmVsaWFibGUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZV9oZWFydGJlYXQgPSBhc3luYyAoY29uZmlnMikgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5fcmVzb2x2ZV9oZWFyYmVhdChjb25maWcyKTtcbiAgICB9O1xuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZV9yZW5kZXJfY29uZmlnKHJlbmRlcl9jb25maWcpIHtcbiAgICAgIGlmICghY29uZmlnKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcmVuZGVyX2lkID0gcmVuZGVyX2NvbmZpZy5yZW5kZXJfaWQ7XG4gICAgICBjb25maWcuY29tcG9uZW50cyA9IFtcbiAgICAgICAgLi4uY29uZmlnLmNvbXBvbmVudHMuZmlsdGVyKChjKSA9PiBjLnByb3BzLnJlbmRlcmVkX2luICE9PSByZW5kZXJfaWQpLFxuICAgICAgICAuLi5yZW5kZXJfY29uZmlnLmNvbXBvbmVudHNcbiAgICAgIF07XG4gICAgICBjb25maWcuZGVwZW5kZW5jaWVzID0gW1xuICAgICAgICAuLi5jb25maWcuZGVwZW5kZW5jaWVzLmZpbHRlcigoZCkgPT4gZC5yZW5kZXJlZF9pbiAhPT0gcmVuZGVyX2lkKSxcbiAgICAgICAgLi4ucmVuZGVyX2NvbmZpZy5kZXBlbmRlbmNpZXNcbiAgICAgIF07XG4gICAgICBjb25zdCBhbnlfc3RhdGUgPSBjb25maWcuY29tcG9uZW50cy5zb21lKChjKSA9PiBjLnR5cGUgPT09IFwic3RhdGVcIik7XG4gICAgICBjb25zdCBhbnlfdW5sb2FkID0gY29uZmlnLmRlcGVuZGVuY2llcy5zb21lKFxuICAgICAgICAoZCkgPT4gZC50YXJnZXRzLnNvbWUoKHQpID0+IHRbMV0gPT09IFwidW5sb2FkXCIpXG4gICAgICApO1xuICAgICAgY29uZmlnLmNvbm5lY3RfaGVhcnRiZWF0ID0gYW55X3N0YXRlIHx8IGFueV91bmxvYWQ7XG4gICAgICBhd2FpdCByZXNvbHZlX2hlYXJ0YmVhdChjb25maWcpO1xuICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgIHR5cGU6IFwicmVuZGVyXCIsXG4gICAgICAgIGRhdGE6IHJlbmRlcl9jb25maWcsXG4gICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgIGZuX2luZGV4XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVfYmxvYihjb25maWcucm9vdCwgcmVzb2x2ZWRfZGF0YSwgZW5kcG9pbnRfaW5mbykudGhlbihcbiAgICAgIGFzeW5jIChfcGF5bG9hZCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBsZXQgaW5wdXRfZGF0YSA9IGhhbmRsZV9wYXlsb2FkKFxuICAgICAgICAgIF9wYXlsb2FkLFxuICAgICAgICAgIGRlcGVuZGVuY3ksXG4gICAgICAgICAgY29uZmlnLmNvbXBvbmVudHMsXG4gICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICBkYXRhOiBpbnB1dF9kYXRhIHx8IFtdLFxuICAgICAgICAgIGV2ZW50X2RhdGEsXG4gICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgdHJpZ2dlcl9pZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2tpcF9xdWV1ZShmbl9pbmRleCwgY29uZmlnKSkge1xuICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICBzdGFnZTogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zdF9kYXRhMihcbiAgICAgICAgICAgIGAke2NvbmZpZy5yb290fS9ydW4ke19lbmRwb2ludC5zdGFydHNXaXRoKFwiL1wiKSA/IF9lbmRwb2ludCA6IGAvJHtfZW5kcG9pbnR9YH0ke3VybF9wYXJhbXMgPyBcIj9cIiArIHVybF9wYXJhbXMgOiBcIlwifWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgIHNlc3Npb25faGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgICkudGhlbigoW291dHB1dCwgc3RhdHVzX2NvZGVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhMiA9IG91dHB1dC5kYXRhO1xuICAgICAgICAgICAgaWYgKHN0YXR1c19jb2RlID09IDIwMCkge1xuICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGFcIixcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IGhhbmRsZV9wYXlsb2FkKFxuICAgICAgICAgICAgICAgICAgZGF0YTIsXG4gICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5LFxuICAgICAgICAgICAgICAgICAgY29uZmlnLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy53aXRoX251bGxfc3RhdGVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGV2ZW50X2RhdGEsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcl9pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dC5yZW5kZXJfY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlX3JlbmRlcl9jb25maWcob3V0cHV0LnJlbmRlcl9jb25maWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICBzdGFnZTogXCJjb21wbGV0ZVwiLFxuICAgICAgICAgICAgICAgIGV0YTogb3V0cHV0LmF2ZXJhZ2VfZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3V0cHV0LmVycm9yLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09IFwid3NcIikge1xuICAgICAgICAgIGNvbnN0IHsgd3NfcHJvdG9jb2wsIGhvc3QgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgICAgICAgICBhcHBfcmVmZXJlbmNlLFxuICAgICAgICAgICAgaGZfdG9rZW5cbiAgICAgICAgICApO1xuICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgIHN0YWdlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChcbiAgICAgICAgICAgIGAke3dzX3Byb3RvY29sfTovLyR7cmVzb2x2ZV9yb290KFxuICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICBjb25maWcucGF0aCxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKX0vcXVldWUvam9pbiR7dXJsX3BhcmFtcyA/IFwiP1wiICsgdXJsX3BhcmFtcyA6IFwiXCJ9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRoaXMuand0KSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIl9fc2lnblwiLCB0aGlzLmp3dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBicm9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogQlJPS0VOX0NPTk5FQ1RJT05fTVNHLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9kYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgc3RhdHVzLCBkYXRhOiBkYXRhMiB9ID0gaGFuZGxlX21lc3NhZ2UoXG4gICAgICAgICAgICAgIF9kYXRhLFxuICAgICAgICAgICAgICBsYXN0X3N0YXR1c1tmbl9pbmRleF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJ1cGRhdGVcIiAmJiBzdGF0dXMgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAuLi5zdGF0dXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChzdGF0dXMuc3RhZ2UgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaGFzaFwiKSB7XG4gICAgICAgICAgICAgIHdlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHsgZm5faW5kZXgsIHNlc3Npb25faGFzaCB9KSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgICAgd2Vic29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyAuLi5wYXlsb2FkLCBzZXNzaW9uX2hhc2ggfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgY29tcGxldGUgPSBzdGF0dXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibG9nXCIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgICAgICBsb2c6IGRhdGEyLmxvZyxcbiAgICAgICAgICAgICAgICBsZXZlbDogZGF0YTIubGV2ZWwsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZGF0YTIuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogZGF0YTIudmlzaWJsZSxcbiAgICAgICAgICAgICAgICBmbl9pbmRleFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJnZW5lcmF0aW5nXCIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAuLi5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhZ2U6IHN0YXR1cyA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzLnN0YWdlLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgZGF0YTogaGFuZGxlX3BheWxvYWQoXG4gICAgICAgICAgICAgICAgICBkYXRhMi5kYXRhLFxuICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2l0aF9udWxsX3N0YXRlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgIGV2ZW50X2RhdGEsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcl9pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAuLi5jb21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgIHN0YWdlOiBzdGF0dXMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1cy5zdGFnZSxcbiAgICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChzZW1pdmVyKGNvbmZpZy52ZXJzaW9uIHx8IFwiMi4wLjBcIiwgXCIzLjZcIikgPCAwKSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBcIm9wZW5cIixcbiAgICAgICAgICAgICAgKCkgPT4gd2Vic29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyBoYXNoOiBzZXNzaW9uX2hhc2ggfSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcm90b2NvbCA9PSBcInNzZVwiKSB7XG4gICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgc3RhZ2U6IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgcXVldWU6IHRydWUsXG4gICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGZuX2luZGV4OiBmbl9pbmRleC50b1N0cmluZygpLFxuICAgICAgICAgICAgc2Vzc2lvbl9oYXNoXG4gICAgICAgICAgfSkudG9TdHJpbmcoKTtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChcbiAgICAgICAgICAgIGAke2NvbmZpZy5yb290fS9xdWV1ZS9qb2luPyR7dXJsX3BhcmFtcyA/IHVybF9wYXJhbXMgKyBcIiZcIiA6IFwiXCJ9JHtwYXJhbXN9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRoaXMuand0KSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIl9fc2lnblwiLCB0aGlzLmp3dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbTIgPSB0aGlzLnN0cmVhbSh1cmwpO1xuICAgICAgICAgIGlmICghc3RyZWFtMikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW5ub3QgY29ubmVjdCB0byBTU0UgZW5kcG9pbnQ6IFwiICsgdXJsLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0yLm9ubWVzc2FnZSA9IGFzeW5jIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBfZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBjb25zdCB7IHR5cGUsIHN0YXR1cywgZGF0YTogZGF0YTIgfSA9IGhhbmRsZV9tZXNzYWdlKFxuICAgICAgICAgICAgICBfZGF0YSxcbiAgICAgICAgICAgICAgbGFzdF9zdGF0dXNbZm5faW5kZXhdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwidXBkYXRlXCIgJiYgc3RhdHVzICYmICFjb21wbGV0ZSkge1xuICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgLi4uc3RhdHVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzLnN0YWdlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0yID09IG51bGwgPyB2b2lkIDAgOiBzdHJlYW0yLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgICAgICAgICBldmVudF9pZCA9IF9kYXRhLmV2ZW50X2lkO1xuICAgICAgICAgICAgICBsZXQgW18sIHN0YXR1czJdID0gYXdhaXQgcG9zdF9kYXRhMihgJHtjb25maWcucm9vdH0vcXVldWUvZGF0YWAsIHtcbiAgICAgICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIHNlc3Npb25faGFzaCxcbiAgICAgICAgICAgICAgICBldmVudF9pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHN0YXR1czIgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBCUk9LRU5fQ09OTkVDVElPTl9NU0csXG4gICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtMiA9PSBudWxsID8gdm9pZCAwIDogc3RyZWFtMi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgIGNvbXBsZXRlID0gc3RhdHVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibG9nXCIsXG4gICAgICAgICAgICAgICAgbG9nOiBkYXRhMi5sb2csXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGRhdGEyLmxldmVsLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGRhdGEyLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IGRhdGEyLnZpc2libGUsXG4gICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZ2VuZXJhdGluZ1wiKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgLi4uc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YWdlOiBzdGF0dXMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1cy5zdGFnZSxcbiAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEyKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGhhbmRsZV9wYXlsb2FkKFxuICAgICAgICAgICAgICAgICAgZGF0YTIuZGF0YSxcbiAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3ksXG4gICAgICAgICAgICAgICAgICBjb25maWcuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgIFwib3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLndpdGhfbnVsbF9zdGF0ZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICBldmVudF9kYXRhLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJfaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgLi4uY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICBzdGFnZTogc3RhdHVzID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMuc3RhZ2UsXG4gICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICBmbl9pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbTIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0cmVhbTIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm90b2NvbCA9PSBcInNzZV92MVwiIHx8IHByb3RvY29sID09IFwic3NlX3YyXCIgfHwgcHJvdG9jb2wgPT0gXCJzc2VfdjIuMVwiIHx8IHByb3RvY29sID09IFwic3NlX3YzXCIpIHtcbiAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICBzdGFnZTogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IGhvc3RuYW1lID0gXCJcIjtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGhvc3RuYW1lID0gKF9hMiA9IHdpbmRvdyA9PSBudWxsID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmhvc3RuYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaGZodWJkZXYgPSBcImRldi5zcGFjZXMuaHVnZ2luZ2ZhY2UudGVjaFwiO1xuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IGhvc3RuYW1lLmluY2x1ZGVzKFwiLmRldi5cIikgPyBgaHR0cHM6Ly9tb29uLSR7aG9zdG5hbWUuc3BsaXQoXCIuXCIpWzFdfS4ke2hmaHViZGV2fWAgOiBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jb2A7XG4gICAgICAgICAgY29uc3QgaXNfaWZyYW1lID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnBhcmVudCAhPSB3aW5kb3c7XG4gICAgICAgICAgY29uc3QgaXNfemVyb2dwdV9zcGFjZSA9IGRlcGVuZGVuY3kuemVyb2dwdSAmJiBjb25maWcuc3BhY2VfaWQ7XG4gICAgICAgICAgY29uc3QgemVyb2dwdV9hdXRoX3Byb21pc2UgPSBpc19pZnJhbWUgJiYgaXNfemVyb2dwdV9zcGFjZSA/IHBvc3RfbWVzc2FnZShcInplcm9ncHUtaGVhZGVyc1wiLCBvcmlnaW4pIDogUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgIGNvbnN0IHBvc3RfZGF0YV9wcm9taXNlID0gemVyb2dwdV9hdXRoX3Byb21pc2UudGhlbigoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RfZGF0YTIoXG4gICAgICAgICAgICAgIGAke2NvbmZpZy5yb290fS9xdWV1ZS9qb2luPyR7dXJsX3BhcmFtc31gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uX2hhc2hcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3N0X2RhdGFfcHJvbWlzZS50aGVuKGFzeW5jIChbcmVzcG9uc2UsIHN0YXR1c10pID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDUwMykge1xuICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogUVVFVUVfRlVMTF9NU0csXG4gICAgICAgICAgICAgICAgcXVldWU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEJST0tFTl9DT05ORUNUSU9OX01TRyxcbiAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXZlbnRfaWQgPSByZXNwb25zZS5ldmVudF9pZDtcbiAgICAgICAgICAgICAgbGV0IGNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24oX2RhdGEpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCBzdGF0dXM6IHN0YXR1czIsIGRhdGE6IGRhdGEyIH0gPSBoYW5kbGVfbWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgX2RhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3Rfc3RhdHVzW2ZuX2luZGV4XVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwiaGVhcnRiZWF0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwidXBkYXRlXCIgJiYgc3RhdHVzMiAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXR1czJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHN0YXR1czI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ1bmV4cGVjdGVkX2Vycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3JcIiwgc3RhdHVzMiA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzMi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChzdGF0dXMyID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMyLm1lc3NhZ2UpIHx8IFwiQW4gVW5leHBlY3RlZCBFcnJvciBPY2N1cnJlZCFcIixcbiAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibG9nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgbG9nOiBkYXRhMi5sb2csXG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGRhdGEyLmxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGRhdGEyLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGRhdGEyLnZpc2libGUsXG4gICAgICAgICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJnZW5lcmF0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0dXMyLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YWdlOiBzdGF0dXMyID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMyLnN0YWdlLFxuICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhMiAmJiBbXCJzc2VfdjJcIiwgXCJzc2VfdjIuMVwiLCBcInNzZV92M1wiXS5pbmNsdWRlcyhwcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcHBseV9kaWZmX3N0cmVhbShwZW5kaW5nX2RpZmZfc3RyZWFtcywgZXZlbnRfaWQsIGRhdGEyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhhbmRsZV9wYXlsb2FkKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTIuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLndpdGhfbnVsbF9zdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICBmbl9pbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEyLnJlbmRlcl9jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVfcmVuZGVyX2NvbmZpZyhkYXRhMi5yZW5kZXJfY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2U6IHN0YXR1czIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1czIuc3RhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbl9pbmRleFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICgoc3RhdHVzMiA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzMi5zdGFnZSkgPT09IFwiY29tcGxldGVcIiB8fCAoc3RhdHVzMiA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzMi5zdGFnZSkgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRfY2FsbGJhY2tzW2V2ZW50X2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudF9jYWxsYmFja3NbZXZlbnRfaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudF9pZCBpbiBwZW5kaW5nX2RpZmZfc3RyZWFtcykge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nX2RpZmZfc3RyZWFtc1tldmVudF9pZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBjbGllbnQgZXhjZXB0aW9uXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQW4gVW5leHBlY3RlZCBFcnJvciBPY2N1cnJlZCFcIixcbiAgICAgICAgICAgICAgICAgICAgcXVldWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoW1wic3NlX3YyXCIsIFwic3NlX3YyLjFcIiwgXCJzc2VfdjNcIl0uaW5jbHVkZXMocHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3N0cmVhbShzdHJlYW1fc3RhdHVzLCB0aGF0LmFib3J0X2NvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1fc3RhdHVzLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChldmVudF9pZCBpbiBwZW5kaW5nX3N0cmVhbV9tZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzW2V2ZW50X2lkXS5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgKG1zZykgPT4gY2FsbGJhY2sobXNnKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzW2V2ZW50X2lkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudF9jYWxsYmFja3NbZXZlbnRfaWRdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgIHVuY2xvc2VkX2V2ZW50cy5hZGQoZXZlbnRfaWQpO1xuICAgICAgICAgICAgICBpZiAoIXN0cmVhbV9zdGF0dXMub3Blbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub3Blbl9zdHJlYW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVycyA9IFtdO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogKCkgPT4gaXRlcmF0b3IsXG4gICAgICBuZXh0LFxuICAgICAgdGhyb3c6IGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICBwdXNoX2Vycm9yKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH0sXG4gICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICAgIHJldHVybiBpdGVyYXRvcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiU3VibWl0IGZ1bmN0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIHRoZW5hYmxlX3JlamVjdChlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHRoZW46IChyZXNvbHZlLCByZWplY3QpID0+IHJlamVjdChlcnJvcilcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldF9lbmRwb2ludF9pbmZvKGFwaV9pbmZvLCBlbmRwb2ludCwgYXBpX21hcCwgY29uZmlnKSB7XG4gIGxldCBmbl9pbmRleDtcbiAgbGV0IGVuZHBvaW50X2luZm87XG4gIGxldCBkZXBlbmRlbmN5O1xuICBpZiAodHlwZW9mIGVuZHBvaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgZm5faW5kZXggPSBlbmRwb2ludDtcbiAgICBlbmRwb2ludF9pbmZvID0gYXBpX2luZm8udW5uYW1lZF9lbmRwb2ludHNbZm5faW5kZXhdO1xuICAgIGRlcGVuZGVuY3kgPSBjb25maWcuZGVwZW5kZW5jaWVzLmZpbmQoKGRlcCkgPT4gZGVwLmlkID09IGVuZHBvaW50KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0cmltbWVkX2VuZHBvaW50ID0gZW5kcG9pbnQucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIGZuX2luZGV4ID0gYXBpX21hcFt0cmltbWVkX2VuZHBvaW50XTtcbiAgICBlbmRwb2ludF9pbmZvID0gYXBpX2luZm8ubmFtZWRfZW5kcG9pbnRzW2VuZHBvaW50LnRyaW0oKV07XG4gICAgZGVwZW5kZW5jeSA9IGNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZChcbiAgICAgIChkZXApID0+IGRlcC5pZCA9PSBhcGlfbWFwW3RyaW1tZWRfZW5kcG9pbnRdXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIGZuX2luZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGVyZSBpcyBubyBlbmRwb2ludCBtYXRjaGluZyB0aGF0IG5hbWUgb2YgZm5faW5kZXggbWF0Y2hpbmcgdGhhdCBudW1iZXIuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiB7IGZuX2luZGV4LCBlbmRwb2ludF9pbmZvLCBkZXBlbmRlbmN5IH07XG59XG5jbGFzcyBDbGllbnQge1xuICBjb25zdHJ1Y3RvcihhcHBfcmVmZXJlbmNlLCBvcHRpb25zID0geyBldmVudHM6IFtcImRhdGFcIl0gfSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhcHBfcmVmZXJlbmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25maWdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFwaV9pbmZvXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhcGlfbWFwXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2Vzc2lvbl9oYXNoXCIsIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImp3dFwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxhc3Rfc3RhdHVzXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29va2llc1wiLCBudWxsKTtcbiAgICAvLyBzdHJlYW1pbmdcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RyZWFtX3N0YXR1c1wiLCB7IG9wZW46IGZhbHNlIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwZW5kaW5nX3N0cmVhbV9tZXNzYWdlc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlbmRpbmdfZGlmZl9zdHJlYW1zXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXZlbnRfY2FsbGJhY2tzXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5jbG9zZWRfZXZlbnRzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWFydGJlYXRfZXZlbnRcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFib3J0X2NvbnRyb2xsZXJcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0cmVhbV9pbnN0YW5jZVwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmlld19hcGlcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwbG9hZF9maWxlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBsb2FkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVfYmxvYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicG9zdF9kYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdWJtaXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZWRpY3RcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wZW5fc3RyZWFtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNvbHZlX2NvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzb2x2ZV9jb29raWVzXCIpO1xuICAgIHRoaXMuYXBwX3JlZmVyZW5jZSA9IGFwcF9yZWZlcmVuY2U7XG4gICAgaWYgKCFvcHRpb25zLmV2ZW50cykge1xuICAgICAgb3B0aW9ucy5ldmVudHMgPSBbXCJkYXRhXCJdO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudmlld19hcGkgPSB2aWV3X2FwaS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBsb2FkX2ZpbGVzID0gdXBsb2FkX2ZpbGVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVfYmxvYiA9IGhhbmRsZV9ibG9iLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wb3N0X2RhdGEgPSBwb3N0X2RhdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1Ym1pdCA9IHN1Ym1pdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJlZGljdCA9IHByZWRpY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9wZW5fc3RyZWFtID0gb3Blbl9zdHJlYW0uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc29sdmVfY29uZmlnID0gcmVzb2x2ZV9jb25maWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc29sdmVfY29va2llcyA9IHJlc29sdmVfY29va2llcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBsb2FkID0gdXBsb2FkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5mZXRjaCA9IHRoaXMuZmV0Y2guYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZV9zcGFjZV9zdWNjZXNzID0gdGhpcy5oYW5kbGVfc3BhY2Vfc3VjY2Vzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RyZWFtID0gdGhpcy5zdHJlYW0uYmluZCh0aGlzKTtcbiAgfVxuICBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKSB8fCB7fSk7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5jb29raWVzKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkNvb2tpZVwiLCB0aGlzLmNvb2tpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2goaW5wdXQsIHsgLi4uaW5pdCwgaGVhZGVycyB9KTtcbiAgfVxuICBzdHJlYW0odXJsKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5jb29raWVzKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChcIkNvb2tpZVwiLCB0aGlzLmNvb2tpZXMpO1xuICAgIH1cbiAgICB0aGlzLmFib3J0X2NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdHJlYW1faW5zdGFuY2UgPSByZWFkYWJsZV9zdHJlYW0odXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IHRoaXMuYWJvcnRfY29udHJvbGxlci5zaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1faW5zdGFuY2U7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoXCJXZWJTb2NrZXRcIiBpbiB3aW5kb3cpKSAmJiAhZ2xvYmFsLldlYlNvY2tldCkge1xuICAgICAgY29uc3Qgd3MgPSBhd2FpdCBpbXBvcnQoXCIuL3dyYXBwZXItQ3ZpU3NlbEcuanNcIik7XG4gICAgICBnbG9iYWwuV2ViU29ja2V0ID0gd3MuV2ViU29ja2V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzb2x2ZV9jb29raWVzKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9yZXNvbHZlX2NvbmZpZygpLnRoZW4oXG4gICAgICAgICh7IGNvbmZpZyB9KSA9PiB0aGlzLl9yZXNvbHZlX2hlYXJiZWF0KGNvbmZpZylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgRXJyb3IoZSk7XG4gICAgfVxuICAgIHRoaXMuYXBpX2luZm8gPSBhd2FpdCB0aGlzLnZpZXdfYXBpKCk7XG4gICAgdGhpcy5hcGlfbWFwID0gbWFwX25hbWVzX3RvX2lkcygoKF9hID0gdGhpcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZXBlbmRlbmNpZXMpIHx8IFtdKTtcbiAgfVxuICBhc3luYyBfcmVzb2x2ZV9oZWFyYmVhdChfY29uZmlnKSB7XG4gICAgaWYgKF9jb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnID0gX2NvbmZpZztcbiAgICAgIGlmICh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5jb25uZWN0X2hlYXJ0YmVhdCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuc3BhY2VfaWQgJiYgdGhpcy5vcHRpb25zLmhmX3Rva2VuKSB7XG4gICAgICAgICAgdGhpcy5qd3QgPSBhd2FpdCBnZXRfand0KFxuICAgICAgICAgICAgdGhpcy5jb25maWcuc3BhY2VfaWQsXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGZfdG9rZW4sXG4gICAgICAgICAgICB0aGlzLmNvb2tpZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfY29uZmlnLnNwYWNlX2lkICYmIHRoaXMub3B0aW9ucy5oZl90b2tlbikge1xuICAgICAgdGhpcy5qd3QgPSBhd2FpdCBnZXRfand0KF9jb25maWcuc3BhY2VfaWQsIHRoaXMub3B0aW9ucy5oZl90b2tlbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5jb25uZWN0X2hlYXJ0YmVhdCkge1xuICAgICAgY29uc3QgaGVhcnRiZWF0X3VybCA9IG5ldyBVUkwoXG4gICAgICAgIGAke3RoaXMuY29uZmlnLnJvb3R9L2hlYXJ0YmVhdC8ke3RoaXMuc2Vzc2lvbl9oYXNofWBcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5qd3QpIHtcbiAgICAgICAgaGVhcnRiZWF0X3VybC5zZWFyY2hQYXJhbXMuc2V0KFwiX19zaWduXCIsIHRoaXMuand0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5oZWFydGJlYXRfZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRfZXZlbnQgPSB0aGlzLnN0cmVhbShoZWFydGJlYXRfdXJsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyA9IHtcbiAgICBldmVudHM6IFtcImRhdGFcIl1cbiAgfSkge1xuICAgIGNvbnN0IGNsaWVudDIgPSBuZXcgdGhpcyhhcHBfcmVmZXJlbmNlLCBvcHRpb25zKTtcbiAgICBhd2FpdCBjbGllbnQyLmluaXQoKTtcbiAgICByZXR1cm4gY2xpZW50MjtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjbG9zZV9zdHJlYW0odGhpcy5zdHJlYW1fc3RhdHVzLCB0aGlzLmFib3J0X2NvbnRyb2xsZXIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkdXBsaWNhdGUoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyA9IHtcbiAgICBldmVudHM6IFtcImRhdGFcIl1cbiAgfSkge1xuICAgIHJldHVybiBkdXBsaWNhdGUoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgX3Jlc29sdmVfY29uZmlnKCkge1xuICAgIGNvbnN0IHsgaHR0cF9wcm90b2NvbCwgaG9zdCwgc3BhY2VfaWQgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgICB0aGlzLmFwcF9yZWZlcmVuY2UsXG4gICAgICB0aGlzLm9wdGlvbnMuaGZfdG9rZW5cbiAgICApO1xuICAgIGNvbnN0IHsgc3RhdHVzX2NhbGxiYWNrIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHNwYWNlX2lkICYmIHN0YXR1c19jYWxsYmFjaykge1xuICAgICAgYXdhaXQgY2hlY2tfYW5kX3dha2Vfc3BhY2Uoc3BhY2VfaWQsIHN0YXR1c19jYWxsYmFjayk7XG4gICAgfVxuICAgIGxldCBjb25maWc7XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZyA9IGF3YWl0IHRoaXMucmVzb2x2ZV9jb25maWcoYCR7aHR0cF9wcm90b2NvbH0vLyR7aG9zdH1gKTtcbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT05GSUdfRVJST1JfTVNHKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZ19zdWNjZXNzKGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHNwYWNlX2lkICYmIHN0YXR1c19jYWxsYmFjaykge1xuICAgICAgICBjaGVja19zcGFjZV9zdGF0dXMoXG4gICAgICAgICAgc3BhY2VfaWQsXG4gICAgICAgICAgUkVfU1BBQ0VfTkFNRS50ZXN0KHNwYWNlX2lkKSA/IFwic3BhY2VfbmFtZVwiIDogXCJzdWJkb21haW5cIixcbiAgICAgICAgICB0aGlzLmhhbmRsZV9zcGFjZV9zdWNjZXNzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RhdHVzX2NhbGxiYWNrKVxuICAgICAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ291bGQgbm90IGxvYWQgdGhpcyBzcGFjZS5cIixcbiAgICAgICAgICAgIGxvYWRfc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICBkZXRhaWw6IFwiTk9UX0ZPVU5EXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbmZpZ19zdWNjZXNzKF9jb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IF9jb25maWc7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJvb3QgPSB0aGlzLmNvbmZpZy5yb290LnJlcGxhY2UoXCJodHRwOi8vXCIsIFwiaHR0cHM6Ly9cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoX3JlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVwYXJlX3JldHVybl9vYmooKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYXBpX2luZm8gPSBhd2FpdCB0aGlzLnZpZXdfYXBpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihBUElfSU5GT19FUlJPUl9NU0cgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlX3JldHVybl9vYmooKTtcbiAgfVxuICBhc3luYyBoYW5kbGVfc3BhY2Vfc3VjY2VzcyhzdGF0dXMpIHtcbiAgICBpZiAoIXRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihDT05GSUdfRVJST1JfTVNHKTtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXNfY2FsbGJhY2sgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoc3RhdHVzX2NhbGxiYWNrKVxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHN0YXR1cyk7XG4gICAgaWYgKHN0YXR1cy5zdGF0dXMgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGF3YWl0IHRoaXMuX3Jlc29sdmVfY29uZmlnKCk7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09ORklHX0VSUk9SX01TRyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2NvbmZpZyA9IGF3YWl0IHRoaXMuY29uZmlnX3N1Y2Nlc3ModGhpcy5jb25maWcpO1xuICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0YXR1c19jYWxsYmFjaykge1xuICAgICAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ291bGQgbm90IGxvYWQgdGhpcyBzcGFjZS5cIixcbiAgICAgICAgICAgIGxvYWRfc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICBkZXRhaWw6IFwiTk9UX0ZPVU5EXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBjb21wb25lbnRfc2VydmVyKGNvbXBvbmVudF9pZCwgZm5fbmFtZSwgZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoQ09ORklHX0VSUk9SX01TRyk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBjb25zdCB7IGhmX3Rva2VuIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgeyBzZXNzaW9uX2hhc2ggfSA9IHRoaXM7XG4gICAgaWYgKGhmX3Rva2VuKSB7XG4gICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dGhpcy5vcHRpb25zLmhmX3Rva2VufWA7XG4gICAgfVxuICAgIGxldCByb290X3VybDtcbiAgICBsZXQgY29tcG9uZW50ID0gdGhpcy5jb25maWcuY29tcG9uZW50cy5maW5kKFxuICAgICAgKGNvbXApID0+IGNvbXAuaWQgPT09IGNvbXBvbmVudF9pZFxuICAgICk7XG4gICAgaWYgKChfYSA9IGNvbXBvbmVudCA9PSBudWxsID8gdm9pZCAwIDogY29tcG9uZW50LnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX2Eucm9vdF91cmwpIHtcbiAgICAgIHJvb3RfdXJsID0gY29tcG9uZW50LnByb3BzLnJvb3RfdXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290X3VybCA9IHRoaXMuY29uZmlnLnJvb3Q7XG4gICAgfVxuICAgIGxldCBib2R5O1xuICAgIGlmIChcImJpbmFyeVwiIGluIGRhdGEpIHtcbiAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEuZGF0YSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImJpbmFyeVwiKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBib2R5LmFwcGVuZChrZXksIGRhdGEuZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIGJvZHkuc2V0KFwiY29tcG9uZW50X2lkXCIsIGNvbXBvbmVudF9pZC50b1N0cmluZygpKTtcbiAgICAgIGJvZHkuc2V0KFwiZm5fbmFtZVwiLCBmbl9uYW1lKTtcbiAgICAgIGJvZHkuc2V0KFwic2Vzc2lvbl9oYXNoXCIsIHNlc3Npb25faGFzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbXBvbmVudF9pZCxcbiAgICAgICAgZm5fbmFtZSxcbiAgICAgICAgc2Vzc2lvbl9oYXNoXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICB9XG4gICAgaWYgKGhmX3Rva2VuKSB7XG4gICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7aGZfdG9rZW59YDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChgJHtyb290X3VybH0vY29tcG9uZW50X3NlcnZlci9gLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIlxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNvdWxkIG5vdCBjb25uZWN0IHRvIGNvbXBvbmVudCBzZXJ2ZXI6IFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICB9XG4gIHNldF9jb29raWVzKHJhd19jb29raWVzKSB7XG4gICAgdGhpcy5jb29raWVzID0gcGFyc2VfYW5kX3NldF9jb29raWVzKHJhd19jb29raWVzKS5qb2luKFwiOyBcIik7XG4gIH1cbiAgcHJlcGFyZV9yZXR1cm5fb2JqKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgcHJlZGljdDogdGhpcy5wcmVkaWN0LFxuICAgICAgc3VibWl0OiB0aGlzLnN1Ym1pdCxcbiAgICAgIHZpZXdfYXBpOiB0aGlzLnZpZXdfYXBpLFxuICAgICAgY29tcG9uZW50X3NlcnZlcjogdGhpcy5jb21wb25lbnRfc2VydmVyXG4gICAgfTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY2xpZW50KGFwcF9yZWZlcmVuY2UsIG9wdGlvbnMgPSB7XG4gIGV2ZW50czogW1wiZGF0YVwiXVxufSkge1xuICByZXR1cm4gYXdhaXQgQ2xpZW50LmNvbm5lY3QoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyk7XG59XG5hc3luYyBmdW5jdGlvbiBkdXBsaWNhdGVfc3BhY2UoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucykge1xuICByZXR1cm4gYXdhaXQgQ2xpZW50LmR1cGxpY2F0ZShhcHBfcmVmZXJlbmNlLCBvcHRpb25zKTtcbn1cbmV4cG9ydCB7XG4gIENsaWVudCxcbiAgRmlsZURhdGEsXG4gIGNsaWVudCxcbiAgZHVwbGljYXRlX3NwYWNlIGFzIGR1cGxpY2F0ZSxcbiAgaGFuZGxlX2ZpbGUsXG4gIHByZWRpY3QsXG4gIHByZXBhcmVfZmlsZXMsXG4gIHN1Ym1pdCxcbiAgdXBsb2FkLFxuICB1cGxvYWRfZmlsZXNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@gradio/client/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@gradio/client/dist/wrapper-CviSselG.js":
/*!**************************************************************!*\
  !*** ./node_modules/@gradio/client/dist/wrapper-CviSselG.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* binding */ receiver$1),\n/* harmony export */   Sender: () => (/* binding */ sender$1),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket$2),\n/* harmony export */   WebSocketServer: () => (/* binding */ websocketServer$1),\n/* harmony export */   createWebSocketStream: () => (/* binding */ stream$1),\n/* harmony export */   \"default\": () => (/* binding */ WebSocket$2)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tls */ \"tls\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! url */ \"url\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule)\n    return n;\n  var f = n.default;\n  if (typeof f == \"function\") {\n    var a = function a2() {\n      if (this instanceof a2) {\n        return Reflect.construct(f, arguments, this.constructor);\n      }\n      return f.apply(this, arguments);\n    };\n    a.prototype = f.prototype;\n  } else\n    a = {};\n  Object.defineProperty(a, \"__esModule\", { value: true });\n  Object.keys(n).forEach(function(k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function() {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\nconst { Duplex } = stream__WEBPACK_IMPORTED_MODULE_0__;\nfunction emitClose$1(stream2) {\n  stream2.emit(\"close\");\n}\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\nfunction duplexOnError(err) {\n  this.removeListener(\"error\", duplexOnError);\n  this.destroy();\n  if (this.listenerCount(\"error\") === 0) {\n    this.emit(\"error\", err);\n  }\n}\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on(\"message\", function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data))\n      ws.pause();\n  });\n  ws.once(\"error\", function error2(err) {\n    if (duplex.destroyed)\n      return;\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once(\"close\", function close() {\n    if (duplex.destroyed)\n      return;\n    duplex.push(null);\n  });\n  duplex._destroy = function(err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose$1, duplex);\n      return;\n    }\n    let called = false;\n    ws.once(\"error\", function error2(err2) {\n      called = true;\n      callback(err2);\n    });\n    ws.once(\"close\", function close() {\n      if (!called)\n        callback(err);\n      process.nextTick(emitClose$1, duplex);\n    });\n    if (terminateOnDestroy)\n      ws.terminate();\n  };\n  duplex._final = function(callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n    if (ws._socket === null)\n      return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted)\n        duplex.destroy();\n    } else {\n      ws._socket.once(\"finish\", function finish() {\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function() {\n    if (ws.isPaused)\n      ws.resume();\n  };\n  duplex._write = function(chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on(\"end\", duplexOnEnd);\n  duplex.on(\"error\", duplexOnError);\n  return duplex;\n}\nvar stream = createWebSocketStream;\nconst stream$1 = /* @__PURE__ */ getDefaultExportFromCjs(stream);\nvar bufferUtil$1 = { exports: {} };\nvar constants = {\n  BINARY_TYPES: [\"nodebuffer\", \"arraybuffer\", \"fragments\"],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n  kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n  kListener: Symbol(\"kListener\"),\n  kStatusCode: Symbol(\"status-code\"),\n  kWebSocket: Symbol(\"websocket\"),\n  NOOP: () => {\n  }\n};\nvar bufferutil = { exports: {} };\nvar nodeGypBuild$1 = { exports: {} };\nfunction commonjsRequire(path) {\n  throw new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar nodeGypBuild;\nvar hasRequiredNodeGypBuild$1;\nfunction requireNodeGypBuild$1() {\n  if (hasRequiredNodeGypBuild$1)\n    return nodeGypBuild;\n  hasRequiredNodeGypBuild$1 = 1;\n  var fs = fs__WEBPACK_IMPORTED_MODULE_2__;\n  var path = path__WEBPACK_IMPORTED_MODULE_3__;\n  var os = os__WEBPACK_IMPORTED_MODULE_4__;\n  var runtimeRequire =  true ? require : 0;\n  var vars = process.config && process.config.variables || {};\n  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;\n  var abi = process.versions.modules;\n  var runtime = isElectron() ? \"electron\" : isNwjs() ? \"node-webkit\" : \"node\";\n  var arch = process.env.npm_config_arch || os.arch();\n  var platform = process.env.npm_config_platform || os.platform();\n  var libc = process.env.LIBC || (isAlpine(platform) ? \"musl\" : \"glibc\");\n  var armv = process.env.ARM_VERSION || (arch === \"arm64\" ? \"8\" : vars.arm_version) || \"\";\n  var uv = (process.versions.uv || \"\").split(\".\")[0];\n  nodeGypBuild = load;\n  function load(dir) {\n    return runtimeRequire(load.resolve(dir));\n  }\n  load.resolve = load.path = function(dir) {\n    dir = path.resolve(dir || \".\");\n    try {\n      var name = runtimeRequire(path.join(dir, \"package.json\")).name.toUpperCase().replace(/-/g, \"_\");\n      if (process.env[name + \"_PREBUILD\"])\n        dir = process.env[name + \"_PREBUILD\"];\n    } catch (err) {\n    }\n    if (!prebuildsOnly) {\n      var release = getFirst(path.join(dir, \"build/Release\"), matchBuild);\n      if (release)\n        return release;\n      var debug = getFirst(path.join(dir, \"build/Debug\"), matchBuild);\n      if (debug)\n        return debug;\n    }\n    var prebuild = resolve(dir);\n    if (prebuild)\n      return prebuild;\n    var nearby = resolve(path.dirname(process.execPath));\n    if (nearby)\n      return nearby;\n    var target = [\n      \"platform=\" + platform,\n      \"arch=\" + arch,\n      \"runtime=\" + runtime,\n      \"abi=\" + abi,\n      \"uv=\" + uv,\n      armv ? \"armv=\" + armv : \"\",\n      \"libc=\" + libc,\n      \"node=\" + process.versions.node,\n      process.versions.electron ? \"electron=\" + process.versions.electron : \"\",\n       true ? \"webpack=true\" : 0\n      // eslint-disable-line\n    ].filter(Boolean).join(\" \");\n    throw new Error(\"No native build was found for \" + target + \"\\n    loaded from: \" + dir + \"\\n\");\n    function resolve(dir2) {\n      var tuples = readdirSync(path.join(dir2, \"prebuilds\")).map(parseTuple);\n      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];\n      if (!tuple)\n        return;\n      var prebuilds = path.join(dir2, \"prebuilds\", tuple.name);\n      var parsed = readdirSync(prebuilds).map(parseTags);\n      var candidates = parsed.filter(matchTags(runtime, abi));\n      var winner = candidates.sort(compareTags(runtime))[0];\n      if (winner)\n        return path.join(prebuilds, winner.file);\n    }\n  };\n  function readdirSync(dir) {\n    try {\n      return fs.readdirSync(dir);\n    } catch (err) {\n      return [];\n    }\n  }\n  function getFirst(dir, filter) {\n    var files = readdirSync(dir).filter(filter);\n    return files[0] && path.join(dir, files[0]);\n  }\n  function matchBuild(name) {\n    return /\\.node$/.test(name);\n  }\n  function parseTuple(name) {\n    var arr = name.split(\"-\");\n    if (arr.length !== 2)\n      return;\n    var platform2 = arr[0];\n    var architectures = arr[1].split(\"+\");\n    if (!platform2)\n      return;\n    if (!architectures.length)\n      return;\n    if (!architectures.every(Boolean))\n      return;\n    return { name, platform: platform2, architectures };\n  }\n  function matchTuple(platform2, arch2) {\n    return function(tuple) {\n      if (tuple == null)\n        return false;\n      if (tuple.platform !== platform2)\n        return false;\n      return tuple.architectures.includes(arch2);\n    };\n  }\n  function compareTuples(a, b) {\n    return a.architectures.length - b.architectures.length;\n  }\n  function parseTags(file) {\n    var arr = file.split(\".\");\n    var extension2 = arr.pop();\n    var tags = { file, specificity: 0 };\n    if (extension2 !== \"node\")\n      return;\n    for (var i = 0; i < arr.length; i++) {\n      var tag = arr[i];\n      if (tag === \"node\" || tag === \"electron\" || tag === \"node-webkit\") {\n        tags.runtime = tag;\n      } else if (tag === \"napi\") {\n        tags.napi = true;\n      } else if (tag.slice(0, 3) === \"abi\") {\n        tags.abi = tag.slice(3);\n      } else if (tag.slice(0, 2) === \"uv\") {\n        tags.uv = tag.slice(2);\n      } else if (tag.slice(0, 4) === \"armv\") {\n        tags.armv = tag.slice(4);\n      } else if (tag === \"glibc\" || tag === \"musl\") {\n        tags.libc = tag;\n      } else {\n        continue;\n      }\n      tags.specificity++;\n    }\n    return tags;\n  }\n  function matchTags(runtime2, abi2) {\n    return function(tags) {\n      if (tags == null)\n        return false;\n      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))\n        return false;\n      if (tags.abi !== abi2 && !tags.napi)\n        return false;\n      if (tags.uv && tags.uv !== uv)\n        return false;\n      if (tags.armv && tags.armv !== armv)\n        return false;\n      if (tags.libc && tags.libc !== libc)\n        return false;\n      return true;\n    };\n  }\n  function runtimeAgnostic(tags) {\n    return tags.runtime === \"node\" && tags.napi;\n  }\n  function compareTags(runtime2) {\n    return function(a, b) {\n      if (a.runtime !== b.runtime) {\n        return a.runtime === runtime2 ? -1 : 1;\n      } else if (a.abi !== b.abi) {\n        return a.abi ? -1 : 1;\n      } else if (a.specificity !== b.specificity) {\n        return a.specificity > b.specificity ? -1 : 1;\n      } else {\n        return 0;\n      }\n    };\n  }\n  function isNwjs() {\n    return !!(process.versions && process.versions.nw);\n  }\n  function isElectron() {\n    if (process.versions && process.versions.electron)\n      return true;\n    if (process.env.ELECTRON_RUN_AS_NODE)\n      return true;\n    return typeof window !== \"undefined\" && window.process && window.process.type === \"renderer\";\n  }\n  function isAlpine(platform2) {\n    return platform2 === \"linux\" && fs.existsSync(\"/etc/alpine-release\");\n  }\n  load.parseTags = parseTags;\n  load.matchTags = matchTags;\n  load.compareTags = compareTags;\n  load.parseTuple = parseTuple;\n  load.matchTuple = matchTuple;\n  load.compareTuples = compareTuples;\n  return nodeGypBuild;\n}\nvar hasRequiredNodeGypBuild;\nfunction requireNodeGypBuild() {\n  if (hasRequiredNodeGypBuild)\n    return nodeGypBuild$1.exports;\n  hasRequiredNodeGypBuild = 1;\n  if (typeof process.addon === \"function\") {\n    nodeGypBuild$1.exports = process.addon.bind(process);\n  } else {\n    nodeGypBuild$1.exports = requireNodeGypBuild$1();\n  }\n  return nodeGypBuild$1.exports;\n}\nvar fallback;\nvar hasRequiredFallback;\nfunction requireFallback() {\n  if (hasRequiredFallback)\n    return fallback;\n  hasRequiredFallback = 1;\n  const mask2 = (source, mask3, output, offset, length) => {\n    for (var i = 0; i < length; i++) {\n      output[offset + i] = source[i] ^ mask3[i & 3];\n    }\n  };\n  const unmask2 = (buffer, mask3) => {\n    const length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] ^= mask3[i & 3];\n    }\n  };\n  fallback = { mask: mask2, unmask: unmask2 };\n  return fallback;\n}\nvar hasRequiredBufferutil;\nfunction requireBufferutil() {\n  if (hasRequiredBufferutil)\n    return bufferutil.exports;\n  hasRequiredBufferutil = 1;\n  try {\n    bufferutil.exports = requireNodeGypBuild()(__dirname);\n  } catch (e) {\n    bufferutil.exports = requireFallback();\n  }\n  return bufferutil.exports;\n}\nvar unmask$1;\nvar mask;\nconst { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;\nconst FastBuffer$2 = Buffer[Symbol.species];\nfunction concat$1(list, totalLength) {\n  if (list.length === 0)\n    return EMPTY_BUFFER$3;\n  if (list.length === 1)\n    return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer$2(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\nfunction _mask(source, mask2, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask2[i & 3];\n  }\n}\nfunction _unmask(buffer, mask2) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask2[i & 3];\n  }\n}\nfunction toArrayBuffer$1(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\nfunction toBuffer$2(data) {\n  toBuffer$2.readOnly = true;\n  if (Buffer.isBuffer(data))\n    return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer$2(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer$2.readOnly = false;\n  }\n  return buf;\n}\nbufferUtil$1.exports = {\n  concat: concat$1,\n  mask: _mask,\n  toArrayBuffer: toArrayBuffer$1,\n  toBuffer: toBuffer$2,\n  unmask: _unmask\n};\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil2 = requireBufferutil();\n    mask = bufferUtil$1.exports.mask = function(source, mask2, output, offset, length) {\n      if (length < 48)\n        _mask(source, mask2, output, offset, length);\n      else\n        bufferUtil2.mask(source, mask2, output, offset, length);\n    };\n    unmask$1 = bufferUtil$1.exports.unmask = function(buffer, mask2) {\n      if (buffer.length < 32)\n        _unmask(buffer, mask2);\n      else\n        bufferUtil2.unmask(buffer, mask2);\n    };\n  } catch (e) {\n  }\n}\nvar bufferUtilExports = bufferUtil$1.exports;\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\nlet Limiter$1 = class Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency)\n      return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n};\nvar limiter = Limiter$1;\nconst zlib = zlib__WEBPACK_IMPORTED_MODULE_1__;\nconst bufferUtil = bufferUtilExports;\nconst Limiter2 = limiter;\nconst { kStatusCode: kStatusCode$2 } = constants;\nconst FastBuffer$1 = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0, 0, 255, 255]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError$1 = Symbol(\"error\");\nlet zlibLimiter;\nlet PerMessageDeflate$4 = class PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter2(concurrency);\n    }\n  }\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return \"permessage-deflate\";\n  }\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(\n          new Error(\n            \"The deflate stream was closed while data was being processed\"\n          )\n        );\n      }\n    }\n  }\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error(\"None of the extension offers can be accepted\");\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === \"number\") {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === \"number\") {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === \"number\") {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n    return params;\n  }\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === \"client_max_window_bits\") {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === \"server_max_window_bits\") {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? \"client\" : \"server\";\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on(\"error\", inflateOnError);\n      this._inflate.on(\"data\", inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin)\n      this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError$1];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data2 = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data2);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? \"server\" : \"client\";\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on(\"data\", deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        return;\n      }\n      let data2 = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n      if (fin) {\n        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);\n      }\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data2);\n    });\n  }\n};\nvar permessageDeflate = PerMessageDeflate$4;\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError$1] = new RangeError(\"Max payload size exceeded\");\n  this[kError$1].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n  this[kError$1][kStatusCode$2] = 1009;\n  this.removeListener(\"data\", inflateOnData);\n  this.reset();\n}\nfunction inflateOnError(err) {\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode$2] = 1007;\n  this[kCallback](err);\n}\nvar validation = { exports: {} };\nconst __viteOptionalPeerDep_utf8Validate_ws = {};\nconst __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: __viteOptionalPeerDep_utf8Validate_ws\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);\nvar isValidUTF8_1;\nconst { isUtf8 } = buffer__WEBPACK_IMPORTED_MODULE_5__;\nconst tokenChars$2 = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 0 - 15\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 16 - 31\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  0,\n  // 32 - 47\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 48 - 63\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  // 64 - 79\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  1,\n  // 80 - 95\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  // 96 - 111\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  1,\n  0,\n  1,\n  0\n  // 112 - 127\n];\nfunction isValidStatusCode$2(code) {\n  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n}\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 128) === 0) {\n      i++;\n    } else if ((buf[i] & 224) === 192) {\n      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 240) === 224) {\n      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong\n      buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 248) === 240) {\n      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong\n      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvalidation.exports = {\n  isValidStatusCode: isValidStatusCode$2,\n  isValidUTF8: _isValidUTF8,\n  tokenChars: tokenChars$2\n};\nif (isUtf8) {\n  isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF82 = require$$1;\n    isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);\n    };\n  } catch (e) {\n  }\n}\nvar validationExports = validation.exports;\nconst { Writable } = stream__WEBPACK_IMPORTED_MODULE_0__;\nconst PerMessageDeflate$3 = permessageDeflate;\nconst {\n  BINARY_TYPES: BINARY_TYPES$1,\n  EMPTY_BUFFER: EMPTY_BUFFER$2,\n  kStatusCode: kStatusCode$1,\n  kWebSocket: kWebSocket$2\n} = constants;\nconst { concat, toArrayBuffer, unmask } = bufferUtilExports;\nconst { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nlet Receiver$1 = class Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES$1[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket$2] = void 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = void 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 8 && this._state == GET_INFO)\n      return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length)\n      return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    cb(err);\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 48) !== 0) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"RSV2 and RSV3 must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_2_3\"\n      );\n    }\n    const compressed = (buf[0] & 64) === 64;\n    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"RSV1 must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_1\"\n      );\n    }\n    this._fin = (buf[0] & 128) === 128;\n    this._opcode = buf[0] & 15;\n    this._payloadLength = buf[1] & 127;\n    if (this._opcode === 0) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"RSV1 must be clear\",\n          true,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n      }\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"invalid opcode 0\",\n          true,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 1 || this._opcode === 2) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 7 && this._opcode < 11) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"FIN must be set\",\n          true,\n          1002,\n          \"WS_ERR_EXPECTED_FIN\"\n        );\n      }\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"RSV1 must be clear\",\n          true,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n      }\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        \"WS_ERR_INVALID_OPCODE\"\n      );\n    }\n    if (!this._fin && !this._fragmented)\n      this._fragmented = this._opcode;\n    this._masked = (buf[1] & 128) === 128;\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"MASK must be set\",\n          true,\n          1002,\n          \"WS_ERR_EXPECTED_MASK\"\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"MASK must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_MASK\"\n      );\n    }\n    if (this._payloadLength === 126)\n      this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127)\n      this._state = GET_PAYLOAD_LENGTH_64;\n    else\n      return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\n        false,\n        1009,\n        \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\n      );\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 8) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"Max payload size exceeded\",\n          false,\n          1009,\n          \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n        );\n      }\n    }\n    if (this._masked)\n      this._state = GET_MASK;\n    else\n      this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER$2;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 7)\n      return this.controlMessage(data);\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    return this.dataMessage();\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err)\n        return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              \"Max payload size exceeded\",\n              false,\n              1009,\n              \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n            )\n          );\n        }\n        this._fragments.push(buf);\n      }\n      const er = this.dataMessage();\n      if (er)\n        return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        let data;\n        if (this._binaryType === \"nodebuffer\") {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === \"arraybuffer\") {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.emit(\"message\", data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            \"invalid UTF-8 sequence\",\n            true,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n        }\n        this.emit(\"message\", buf, false);\n      }\n    }\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 8) {\n      this._loop = false;\n      if (data.length === 0) {\n        this.emit(\"conclude\", 1005, EMPTY_BUFFER$2);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode$1(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            \"WS_ERR_INVALID_CLOSE_CODE\"\n          );\n        }\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            \"invalid UTF-8 sequence\",\n            true,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n        }\n        this.emit(\"conclude\", code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 9) {\n      this.emit(\"ping\", data);\n    } else {\n      this.emit(\"pong\", data);\n    }\n    this._state = GET_INFO;\n  }\n};\nvar receiver = Receiver$1;\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode$1] = statusCode;\n  return err;\n}\nconst receiver$1 = /* @__PURE__ */ getDefaultExportFromCjs(receiver);\nconst { randomFillSync } = crypto__WEBPACK_IMPORTED_MODULE_8__;\nconst PerMessageDeflate$2 = permessageDeflate;\nconst { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;\nconst { isValidStatusCode } = validationExports;\nconst { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nlet Sender$1 = class Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask2;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n    if (options.mask) {\n      mask2 = options.maskBuffer || maskBuffer;\n      if (options.generateMask) {\n        options.generateMask(mask2);\n      } else {\n        randomFillSync(mask2, 0, 4);\n      }\n      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;\n      offset = 6;\n    }\n    let dataLength;\n    if (typeof data === \"string\") {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n    let payloadLength = dataLength;\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 128 : options.opcode;\n    if (options.rsv1)\n      target[0] |= 64;\n    target[1] = payloadLength;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n    if (!options.mask)\n      return [target, data];\n    target[1] |= 128;\n    target[offset - 4] = mask2[0];\n    target[offset - 3] = mask2[1];\n    target[offset - 2] = mask2[2];\n    target[offset - 1] = mask2[3];\n    if (skipMasking)\n      return [target, data];\n    if (merge) {\n      applyMask(data, mask2, target, offset, dataLength);\n      return [target];\n    }\n    applyMask(data, mask2, data, 0, dataLength);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask2, cb) {\n    let buf;\n    if (code === void 0) {\n      buf = EMPTY_BUFFER$1;\n    } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n      throw new TypeError(\"First argument must be a valid error code number\");\n    } else if (data === void 0 || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n      if (length > 123) {\n        throw new RangeError(\"The message must not be greater than 123 bytes\");\n      }\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      if (typeof data === \"string\") {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 8,\n      readOnly: false,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 9,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 10,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin)\n      this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          \"The socket was closed while data was being compressed\"\n        );\n        if (typeof cb === \"function\")\n          cb(err);\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === \"function\")\n            callback(err);\n        }\n        return;\n      }\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n};\nvar sender = Sender$1;\nconst sender$1 = /* @__PURE__ */ getDefaultExportFromCjs(sender);\nconst { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, \"target\", { enumerable: true });\nObject.defineProperty(Event.prototype, \"type\", { enumerable: true });\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === void 0 ? 0 : options.code;\n    this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n    this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, \"reason\", { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", { enumerable: true });\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === void 0 ? null : options.error;\n    this[kMessage] = options.message === void 0 ? \"\" : options.message;\n  }\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, \"message\", { enumerable: true });\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === void 0 ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", { enumerable: true });\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === \"message\") {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent(\"message\", {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"close\") {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent(\"close\", {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"error\") {\n      wrapper = function onError(error2) {\n        const event = new ErrorEvent(\"error\", {\n          error: error2,\n          message: error2.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"open\") {\n      wrapper = function onOpen() {\n        const event = new Event(\"open\");\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];\n    wrapper[kListener$1] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nvar eventTarget = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === \"object\" && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\nconst { tokenChars: tokenChars$1 } = validationExports;\nfunction push(dest, name, elem) {\n  if (dest[name] === void 0)\n    dest[name] = [elem];\n  else\n    dest[name].push(elem);\n}\nfunction parse$2(header) {\n  const offers = /* @__PURE__ */ Object.create(null);\n  let params = /* @__PURE__ */ Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (i !== 0 && (code === 32 || code === 9)) {\n        if (end === -1 && start !== -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        const name = header.slice(start, end);\n        if (code === 44) {\n          push(offers, name, params);\n          params = /* @__PURE__ */ Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (code === 32 || code === 9) {\n        if (end === -1 && start !== -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */ Object.create(null);\n          extensionName = void 0;\n        }\n        start = end = -1;\n      } else if (code === 61 && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      if (isEscaping) {\n        if (tokenChars$1[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1)\n          start = i;\n        else if (!mustUnescape)\n          mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars$1[code] === 1) {\n          if (start === -1)\n            start = i;\n        } else if (code === 34 && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 92) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (start !== -1 && (code === 32 || code === 9)) {\n        if (end === -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, \"\");\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */ Object.create(null);\n          extensionName = void 0;\n        }\n        paramName = void 0;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 32 || code === 9) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  if (end === -1)\n    end = i;\n  const token = header.slice(start, end);\n  if (extensionName === void 0) {\n    push(offers, token, params);\n  } else {\n    if (paramName === void 0) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, \"\"));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\nfunction format$1(extensions) {\n  return Object.keys(extensions).map((extension2) => {\n    let configurations = extensions[extension2];\n    if (!Array.isArray(configurations))\n      configurations = [configurations];\n    return configurations.map((params) => {\n      return [extension2].concat(\n        Object.keys(params).map((k) => {\n          let values = params[k];\n          if (!Array.isArray(values))\n            values = [values];\n          return values.map((v) => v === true ? k : `${k}=${v}`).join(\"; \");\n        })\n      ).join(\"; \");\n    }).join(\", \");\n  }).join(\", \");\n}\nvar extension$1 = { format: format$1, parse: parse$2 };\nconst EventEmitter$1 = events__WEBPACK_IMPORTED_MODULE_9__;\nconst https = https__WEBPACK_IMPORTED_MODULE_10__;\nconst http$1 = http__WEBPACK_IMPORTED_MODULE_11__;\nconst net = net__WEBPACK_IMPORTED_MODULE_6__;\nconst tls = tls__WEBPACK_IMPORTED_MODULE_7__;\nconst { randomBytes, createHash: createHash$1 } = crypto__WEBPACK_IMPORTED_MODULE_8__;\nconst { URL } = url__WEBPACK_IMPORTED_MODULE_12__;\nconst PerMessageDeflate$1 = permessageDeflate;\nconst Receiver2 = receiver;\nconst Sender2 = sender;\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID: GUID$1,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket: kWebSocket$1,\n  NOOP\n} = constants;\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = eventTarget;\nconst { format, parse: parse$1 } = extension$1;\nconst { toBuffer } = bufferUtilExports;\nconst closeTimeout = 30 * 1e3;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [8, 13];\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nlet WebSocket$1 = class WebSocket extends EventEmitter$1 {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = \"\";\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === void 0) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === \"object\" && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type))\n      return;\n    this._binaryType = type;\n    if (this._receiver)\n      this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket)\n      return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver2 = new Receiver2({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender2(socket, this._extensions, options.generateMask);\n    this._receiver = receiver2;\n    this._socket = socket;\n    receiver2[kWebSocket$1] = this;\n    socket[kWebSocket$1] = this;\n    receiver2.on(\"conclude\", receiverOnConclude);\n    receiver2.on(\"drain\", receiverOnDrain);\n    receiver2.on(\"error\", receiverOnError);\n    receiver2.on(\"message\", receiverOnMessage);\n    receiver2.on(\"ping\", receiverOnPing);\n    receiver2.on(\"pong\", receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0)\n      socket.unshift(head);\n    socket.on(\"close\", socketOnClose);\n    socket.on(\"data\", socketOnData);\n    socket.on(\"end\", socketOnEnd);\n    socket.on(\"error\", socketOnError$1);\n    this._readyState = WebSocket.OPEN;\n    this.emit(\"open\");\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit(\"close\", this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate$1.extensionName]) {\n      this._extensions[PerMessageDeflate$1.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit(\"close\", this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED)\n      return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      if (err)\n        return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0)\n      mask2 = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0)\n      mask2 = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain)\n      this._socket.resume();\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== \"string\",\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate$1.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED)\n      return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n};\nObject.defineProperty(WebSocket$1, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n[\n  \"binaryType\",\n  \"bufferedAmount\",\n  \"extensions\",\n  \"isPaused\",\n  \"protocol\",\n  \"readyState\",\n  \"url\"\n].forEach((property) => {\n  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });\n});\n[\"open\", \"error\", \"close\", \"message\"].forEach((method) => {\n  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute])\n          return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== \"function\")\n        return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket$1.prototype.addEventListener = addEventListener;\nWebSocket$1.prototype.removeEventListener = removeEventListener;\nvar websocket = WebSocket$1;\nfunction initAsClient(websocket2, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: void 0,\n    socketPath: void 0,\n    hostname: void 0,\n    protocol: void 0,\n    timeout: void 0,\n    method: \"GET\",\n    host: void 0,\n    path: void 0,\n    port: void 0\n  };\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`\n    );\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket2._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n    websocket2._url = address;\n  }\n  const isSecure = parsedUrl.protocol === \"wss:\";\n  const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"`;\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = \"The URL contains a fragment identifier\";\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket2._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket2, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString(\"base64\");\n  const request = isSecure ? https.request : http$1.request;\n  const protocolSet = /* @__PURE__ */ new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    \"Sec-WebSocket-Version\": opts.protocolVersion,\n    \"Sec-WebSocket-Key\": key,\n    Connection: \"Upgrade\",\n    Upgrade: \"websocket\"\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate$1(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError(\n          \"An invalid or duplicated subprotocol was specified\"\n        );\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(\":\");\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket2._redirects === 0) {\n      websocket2._originalIpc = isIpcUrl;\n      websocket2._originalSecure = isSecure;\n      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n      options = { ...options, headers: {} };\n      if (headers) {\n        for (const [key2, value] of Object.entries(headers)) {\n          options.headers[key2.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket2.listenerCount(\"redirect\") === 0) {\n      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;\n      if (!isSameHost || websocket2._originalSecure && !isSecure) {\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost)\n          delete opts.headers.host;\n        opts.auth = void 0;\n      }\n    }\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n    }\n    req = websocket2._req = request(opts);\n    if (websocket2._redirects) {\n      websocket2.emit(\"redirect\", websocket2.url, req);\n    }\n  } else {\n    req = websocket2._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on(\"timeout\", () => {\n      abortHandshake$1(websocket2, req, \"Opening handshake has timed out\");\n    });\n  }\n  req.on(\"error\", (err) => {\n    if (req === null || req[kAborted])\n      return;\n    req = websocket2._req = null;\n    emitErrorAndClose(websocket2, err);\n  });\n  req.on(\"response\", (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket2._redirects > opts.maxRedirects) {\n        abortHandshake$1(websocket2, req, \"Maximum redirects exceeded\");\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket2, err);\n        return;\n      }\n      initAsClient(websocket2, addr, protocols, options);\n    } else if (!websocket2.emit(\"unexpected-response\", req, res)) {\n      abortHandshake$1(\n        websocket2,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n  req.on(\"upgrade\", (res, socket, head) => {\n    websocket2.emit(\"upgrade\", res);\n    if (websocket2.readyState !== WebSocket$1.CONNECTING)\n      return;\n    req = websocket2._req = null;\n    if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshake$1(websocket2, socket, \"Invalid Upgrade header\");\n      return;\n    }\n    const digest = createHash$1(\"sha1\").update(key + GUID$1).digest(\"base64\");\n    if (res.headers[\"sec-websocket-accept\"] !== digest) {\n      abortHandshake$1(websocket2, socket, \"Invalid Sec-WebSocket-Accept header\");\n      return;\n    }\n    const serverProt = res.headers[\"sec-websocket-protocol\"];\n    let protError;\n    if (serverProt !== void 0) {\n      if (!protocolSet.size) {\n        protError = \"Server sent a subprotocol but none was requested\";\n      } else if (!protocolSet.has(serverProt)) {\n        protError = \"Server sent an invalid subprotocol\";\n      }\n    } else if (protocolSet.size) {\n      protError = \"Server sent no subprotocol\";\n    }\n    if (protError) {\n      abortHandshake$1(websocket2, socket, protError);\n      return;\n    }\n    if (serverProt)\n      websocket2._protocol = serverProt;\n    const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n    if (secWebSocketExtensions !== void 0) {\n      if (!perMessageDeflate) {\n        const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse$1(secWebSocketExtensions);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {\n        const message = \"Server indicated an extension that was not requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;\n    }\n    websocket2.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket2);\n  } else {\n    req.end();\n  }\n}\nfunction emitErrorAndClose(websocket2, err) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2.emit(\"error\", err);\n  websocket2.emitClose();\n}\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\nfunction tlsConnect(options) {\n  options.path = void 0;\n  if (!options.servername && options.servername !== \"\") {\n    options.servername = net.isIP(options.host) ? \"\" : options.host;\n  }\n  return tls.connect(options);\n}\nfunction abortHandshake$1(websocket2, stream2, message) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake$1);\n  if (stream2.setHeader) {\n    stream2[kAborted] = true;\n    stream2.abort();\n    if (stream2.socket && !stream2.socket.destroyed) {\n      stream2.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket2, err);\n  } else {\n    stream2.destroy(err);\n    stream2.once(\"error\", websocket2.emit.bind(websocket2, \"error\"));\n    stream2.once(\"close\", websocket2.emitClose.bind(websocket2));\n  }\n}\nfunction sendAfterClose(websocket2, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n    if (websocket2._socket)\n      websocket2._sender._bufferedBytes += length;\n    else\n      websocket2._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\nfunction receiverOnConclude(code, reason) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._closeFrameReceived = true;\n  websocket2._closeMessage = reason;\n  websocket2._closeCode = code;\n  if (websocket2._socket[kWebSocket$1] === void 0)\n    return;\n  websocket2._socket.removeListener(\"data\", socketOnData);\n  process.nextTick(resume, websocket2._socket);\n  if (code === 1005)\n    websocket2.close();\n  else\n    websocket2.close(code, reason);\n}\nfunction receiverOnDrain() {\n  const websocket2 = this[kWebSocket$1];\n  if (!websocket2.isPaused)\n    websocket2._socket.resume();\n}\nfunction receiverOnError(err) {\n  const websocket2 = this[kWebSocket$1];\n  if (websocket2._socket[kWebSocket$1] !== void 0) {\n    websocket2._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket2._socket);\n    websocket2.close(err[kStatusCode]);\n  }\n  websocket2.emit(\"error\", err);\n}\nfunction receiverOnFinish() {\n  this[kWebSocket$1].emitClose();\n}\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket$1].emit(\"message\", data, isBinary);\n}\nfunction receiverOnPing(data) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2.pong(data, !websocket2._isServer, NOOP);\n  websocket2.emit(\"ping\", data);\n}\nfunction receiverOnPong(data) {\n  this[kWebSocket$1].emit(\"pong\", data);\n}\nfunction resume(stream2) {\n  stream2.resume();\n}\nfunction socketOnClose() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"close\", socketOnClose);\n  this.removeListener(\"data\", socketOnData);\n  this.removeListener(\"end\", socketOnEnd);\n  websocket2._readyState = WebSocket$1.CLOSING;\n  let chunk;\n  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {\n    websocket2._receiver.write(chunk);\n  }\n  websocket2._receiver.end();\n  this[kWebSocket$1] = void 0;\n  clearTimeout(websocket2._closeTimer);\n  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {\n    websocket2.emitClose();\n  } else {\n    websocket2._receiver.on(\"error\", receiverOnFinish);\n    websocket2._receiver.on(\"finish\", receiverOnFinish);\n  }\n}\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket$1]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\nfunction socketOnEnd() {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2._receiver.end();\n  this.end();\n}\nfunction socketOnError$1() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"error\", socketOnError$1);\n  this.on(\"error\", NOOP);\n  if (websocket2) {\n    websocket2._readyState = WebSocket$1.CLOSING;\n    this.destroy();\n  }\n}\nconst WebSocket$2 = /* @__PURE__ */ getDefaultExportFromCjs(websocket);\nconst { tokenChars } = validationExports;\nfunction parse(header) {\n  const protocols = /* @__PURE__ */ new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1)\n        start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1)\n        end = i;\n    } else if (code === 44) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1)\n        end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2)) {\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol2);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nvar subprotocol$1 = { parse };\nconst EventEmitter = events__WEBPACK_IMPORTED_MODULE_9__;\nconst http = http__WEBPACK_IMPORTED_MODULE_11__;\nconst { createHash } = crypto__WEBPACK_IMPORTED_MODULE_8__;\nconst extension = extension$1;\nconst PerMessageDeflate2 = permessageDeflate;\nconst subprotocol = subprotocol$1;\nconst WebSocket2 = websocket;\nconst { GUID, kWebSocket } = constants;\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket2,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\");\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, \"listening\"),\n        error: this.emit.bind(this, \"error\"),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true)\n      options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = /* @__PURE__ */ new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server)\n      return null;\n    return this._server.address();\n  }\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb)\n      this.once(\"close\", cb);\n    if (this._state === CLOSING)\n      return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"?\");\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on(\"error\", socketOnError);\n    const key = req.headers[\"sec-websocket-key\"];\n    const version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      const message = \"Invalid HTTP method\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      const message = \"Invalid Upgrade header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!key || !keyRegex.test(key)) {\n      const message = \"Missing or invalid Sec-WebSocket-Key header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = \"Missing or invalid Sec-WebSocket-Version header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = /* @__PURE__ */ new Set();\n    if (secWebSocketProtocol !== void 0) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Protocol header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n      const perMessageDeflate = new PerMessageDeflate2(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate2.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);\n          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info))\n        return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    if (!socket.readable || !socket.writable)\n      return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error(\n        \"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\"\n      );\n    }\n    if (this._state > RUNNING)\n      return abortHandshake(socket, 503);\n    const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n    const headers = [\n      \"HTTP/1.1 101 Switching Protocols\",\n      \"Upgrade: websocket\",\n      \"Connection: Upgrade\",\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n    const ws = new this.options.WebSocket(null);\n    if (protocols.size) {\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate2.extensionName]) {\n      const params = extensions[PerMessageDeflate2.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate2.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n    this.emit(\"headers\", headers, req);\n    socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n    socket.removeListener(\"error\", socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on(\"close\", () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nvar websocketServer = WebSocketServer;\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map))\n    server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit(\"close\");\n}\nfunction socketOnError() {\n  this.destroy();\n}\nfunction abortHandshake(socket, code, message, headers) {\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once(\"finish\", socket.destroy);\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message\n  );\n}\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit(\"wsClientError\", err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\nconst websocketServer$1 = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdyYWRpby9jbGllbnQvZGlzdC93cmFwcGVyLUN2aVNzZWxHLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDQTtBQUNGO0FBQ0U7QUFDSjtBQUNNO0FBQ0w7QUFDQTtBQUNHO0FBQ0U7QUFDRDtBQUNEO0FBQ0g7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLFNBQVMsRUFBRSxtQ0FBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0EsUUFBUSxTQUFTLEVBQUUsbUNBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXLEVBQUUsbUNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLFFBQVEsZ0NBQWdDO0FBQ3hDLFFBQVEsc0RBQXNEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0I7QUFDN0UsQ0FBQztBQUNEO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQix1QkFBdUIsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUIsR0FBRyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU0sRUFBRSx3QkFBd0I7QUFDaEQsdUNBQXVDLEVBQUUsSUFBSSxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBUUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1yZWFjdC1hcHAvLi9ub2RlX21vZHVsZXMvQGdyYWRpby9jbGllbnQvZGlzdC93cmFwcGVyLUN2aVNzZWxHLmpzPzA3ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSBcInN0cmVhbVwiO1xuaW1wb3J0IHJlcXVpcmUkJDAkMiBmcm9tIFwiemxpYlwiO1xuaW1wb3J0IHJlcXVpcmUkJDAkMSBmcm9tIFwiZnNcIjtcbmltcG9ydCByZXF1aXJlJCQxJDEgZnJvbSBcInBhdGhcIjtcbmltcG9ydCByZXF1aXJlJCQyIGZyb20gXCJvc1wiO1xuaW1wb3J0IHJlcXVpcmUkJDAkMyBmcm9tIFwiYnVmZmVyXCI7XG5pbXBvcnQgcmVxdWlyZSQkMyBmcm9tIFwibmV0XCI7XG5pbXBvcnQgcmVxdWlyZSQkNCBmcm9tIFwidGxzXCI7XG5pbXBvcnQgcmVxdWlyZSQkNSBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgcmVxdWlyZSQkMCQ0IGZyb20gXCJldmVudHNcIjtcbmltcG9ydCByZXF1aXJlJCQxJDIgZnJvbSBcImh0dHBzXCI7XG5pbXBvcnQgcmVxdWlyZSQkMiQxIGZyb20gXCJodHRwXCI7XG5pbXBvcnQgcmVxdWlyZSQkNyBmcm9tIFwidXJsXCI7XG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh4KSB7XG4gIHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgXCJkZWZhdWx0XCIpID8geFtcImRlZmF1bHRcIl0gOiB4O1xufVxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHtcbiAgaWYgKG4uX19lc01vZHVsZSlcbiAgICByZXR1cm4gbjtcbiAgdmFyIGYgPSBuLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYSA9IGZ1bmN0aW9uIGEyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBhMikge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoZiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBhLnByb3RvdHlwZSA9IGYucHJvdG90eXBlO1xuICB9IGVsc2VcbiAgICBhID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIGspO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ba107XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlJCQwO1xuZnVuY3Rpb24gZW1pdENsb3NlJDEoc3RyZWFtMikge1xuICBzdHJlYW0yLmVtaXQoXCJjbG9zZVwiKTtcbn1cbmZ1bmN0aW9uIGR1cGxleE9uRW5kKCkge1xuICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudChcImVycm9yXCIpID09PSAwKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG4gIHdzLm9uKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBtZXNzYWdlKG1zZywgaXNCaW5hcnkpIHtcbiAgICBjb25zdCBkYXRhID0gIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSlcbiAgICAgIHdzLnBhdXNlKCk7XG4gIH0pO1xuICB3cy5vbmNlKFwiZXJyb3JcIiwgZnVuY3Rpb24gZXJyb3IyKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRlcm1pbmF0ZU9uRGVzdHJveSA9IGZhbHNlO1xuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuICB3cy5vbmNlKFwiY2xvc2VcIiwgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpXG4gICAgICByZXR1cm47XG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlJDEsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICB3cy5vbmNlKFwiZXJyb3JcIiwgZnVuY3Rpb24gZXJyb3IyKGVycjIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIyKTtcbiAgICB9KTtcbiAgICB3cy5vbmNlKFwiY2xvc2VcIiwgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZClcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlJDEsIGR1cGxleCk7XG4gICAgfSk7XG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSlcbiAgICAgIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZShcIm9wZW5cIiwgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgICAgIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZShcImZpbmlzaFwiLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAod3MuaXNQYXVzZWQpXG4gICAgICB3cy5yZXN1bWUoKTtcbiAgfTtcbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZShcIm9wZW5cIiwgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG4gIGR1cGxleC5vbihcImVuZFwiLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbihcImVycm9yXCIsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxudmFyIHN0cmVhbSA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbmNvbnN0IHN0cmVhbSQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHN0cmVhbSk7XG52YXIgYnVmZmVyVXRpbCQxID0geyBleHBvcnRzOiB7fSB9O1xudmFyIGNvbnN0YW50cyA9IHtcbiAgQklOQVJZX1RZUEVTOiBbXCJub2RlYnVmZmVyXCIsIFwiYXJyYXlidWZmZXJcIiwgXCJmcmFnbWVudHNcIl0sXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBHVUlEOiBcIjI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiLFxuICBrRm9yT25FdmVudEF0dHJpYnV0ZTogU3ltYm9sKFwia0lzRm9yT25FdmVudEF0dHJpYnV0ZVwiKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woXCJrTGlzdGVuZXJcIiksXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woXCJzdGF0dXMtY29kZVwiKSxcbiAga1dlYlNvY2tldDogU3ltYm9sKFwid2Vic29ja2V0XCIpLFxuICBOT09QOiAoKSA9PiB7XG4gIH1cbn07XG52YXIgYnVmZmVydXRpbCA9IHsgZXhwb3J0czoge30gfTtcbnZhciBub2RlR3lwQnVpbGQkMSA9IHsgZXhwb3J0czoge30gfTtcbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZShwYXRoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgcGF0aCArICdcIi4gUGxlYXNlIGNvbmZpZ3VyZSB0aGUgZHluYW1pY1JlcXVpcmVUYXJnZXRzIG9yL2FuZCBpZ25vcmVEeW5hbWljUmVxdWlyZXMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIHdvcmsuJyk7XG59XG52YXIgbm9kZUd5cEJ1aWxkO1xudmFyIGhhc1JlcXVpcmVkTm9kZUd5cEJ1aWxkJDE7XG5mdW5jdGlvbiByZXF1aXJlTm9kZUd5cEJ1aWxkJDEoKSB7XG4gIGlmIChoYXNSZXF1aXJlZE5vZGVHeXBCdWlsZCQxKVxuICAgIHJldHVybiBub2RlR3lwQnVpbGQ7XG4gIGhhc1JlcXVpcmVkTm9kZUd5cEJ1aWxkJDEgPSAxO1xuICB2YXIgZnMgPSByZXF1aXJlJCQwJDE7XG4gIHZhciBwYXRoID0gcmVxdWlyZSQkMSQxO1xuICB2YXIgb3MgPSByZXF1aXJlJCQyO1xuICB2YXIgcnVudGltZVJlcXVpcmUgPSB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXyA9PT0gXCJmdW5jdGlvblwiID8gX19ub25fd2VicGFja19yZXF1aXJlX18gOiBjb21tb25qc1JlcXVpcmU7XG4gIHZhciB2YXJzID0gcHJvY2Vzcy5jb25maWcgJiYgcHJvY2Vzcy5jb25maWcudmFyaWFibGVzIHx8IHt9O1xuICB2YXIgcHJlYnVpbGRzT25seSA9ICEhcHJvY2Vzcy5lbnYuUFJFQlVJTERTX09OTFk7XG4gIHZhciBhYmkgPSBwcm9jZXNzLnZlcnNpb25zLm1vZHVsZXM7XG4gIHZhciBydW50aW1lID0gaXNFbGVjdHJvbigpID8gXCJlbGVjdHJvblwiIDogaXNOd2pzKCkgPyBcIm5vZGUtd2Via2l0XCIgOiBcIm5vZGVcIjtcbiAgdmFyIGFyY2ggPSBwcm9jZXNzLmVudi5ucG1fY29uZmlnX2FyY2ggfHwgb3MuYXJjaCgpO1xuICB2YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5ucG1fY29uZmlnX3BsYXRmb3JtIHx8IG9zLnBsYXRmb3JtKCk7XG4gIHZhciBsaWJjID0gcHJvY2Vzcy5lbnYuTElCQyB8fCAoaXNBbHBpbmUocGxhdGZvcm0pID8gXCJtdXNsXCIgOiBcImdsaWJjXCIpO1xuICB2YXIgYXJtdiA9IHByb2Nlc3MuZW52LkFSTV9WRVJTSU9OIHx8IChhcmNoID09PSBcImFybTY0XCIgPyBcIjhcIiA6IHZhcnMuYXJtX3ZlcnNpb24pIHx8IFwiXCI7XG4gIHZhciB1diA9IChwcm9jZXNzLnZlcnNpb25zLnV2IHx8IFwiXCIpLnNwbGl0KFwiLlwiKVswXTtcbiAgbm9kZUd5cEJ1aWxkID0gbG9hZDtcbiAgZnVuY3Rpb24gbG9hZChkaXIpIHtcbiAgICByZXR1cm4gcnVudGltZVJlcXVpcmUobG9hZC5yZXNvbHZlKGRpcikpO1xuICB9XG4gIGxvYWQucmVzb2x2ZSA9IGxvYWQucGF0aCA9IGZ1bmN0aW9uKGRpcikge1xuICAgIGRpciA9IHBhdGgucmVzb2x2ZShkaXIgfHwgXCIuXCIpO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbmFtZSA9IHJ1bnRpbWVSZXF1aXJlKHBhdGguam9pbihkaXIsIFwicGFja2FnZS5qc29uXCIpKS5uYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgICBpZiAocHJvY2Vzcy5lbnZbbmFtZSArIFwiX1BSRUJVSUxEXCJdKVxuICAgICAgICBkaXIgPSBwcm9jZXNzLmVudltuYW1lICsgXCJfUFJFQlVJTERcIl07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgfVxuICAgIGlmICghcHJlYnVpbGRzT25seSkge1xuICAgICAgdmFyIHJlbGVhc2UgPSBnZXRGaXJzdChwYXRoLmpvaW4oZGlyLCBcImJ1aWxkL1JlbGVhc2VcIiksIG1hdGNoQnVpbGQpO1xuICAgICAgaWYgKHJlbGVhc2UpXG4gICAgICAgIHJldHVybiByZWxlYXNlO1xuICAgICAgdmFyIGRlYnVnID0gZ2V0Rmlyc3QocGF0aC5qb2luKGRpciwgXCJidWlsZC9EZWJ1Z1wiKSwgbWF0Y2hCdWlsZCk7XG4gICAgICBpZiAoZGVidWcpXG4gICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG4gICAgdmFyIHByZWJ1aWxkID0gcmVzb2x2ZShkaXIpO1xuICAgIGlmIChwcmVidWlsZClcbiAgICAgIHJldHVybiBwcmVidWlsZDtcbiAgICB2YXIgbmVhcmJ5ID0gcmVzb2x2ZShwYXRoLmRpcm5hbWUocHJvY2Vzcy5leGVjUGF0aCkpO1xuICAgIGlmIChuZWFyYnkpXG4gICAgICByZXR1cm4gbmVhcmJ5O1xuICAgIHZhciB0YXJnZXQgPSBbXG4gICAgICBcInBsYXRmb3JtPVwiICsgcGxhdGZvcm0sXG4gICAgICBcImFyY2g9XCIgKyBhcmNoLFxuICAgICAgXCJydW50aW1lPVwiICsgcnVudGltZSxcbiAgICAgIFwiYWJpPVwiICsgYWJpLFxuICAgICAgXCJ1dj1cIiArIHV2LFxuICAgICAgYXJtdiA/IFwiYXJtdj1cIiArIGFybXYgOiBcIlwiLFxuICAgICAgXCJsaWJjPVwiICsgbGliYyxcbiAgICAgIFwibm9kZT1cIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgICAgIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gPyBcImVsZWN0cm9uPVwiICsgcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiA6IFwiXCIsXG4gICAgICB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXyA9PT0gXCJmdW5jdGlvblwiID8gXCJ3ZWJwYWNrPXRydWVcIiA6IFwiXCJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBuYXRpdmUgYnVpbGQgd2FzIGZvdW5kIGZvciBcIiArIHRhcmdldCArIFwiXFxuICAgIGxvYWRlZCBmcm9tOiBcIiArIGRpciArIFwiXFxuXCIpO1xuICAgIGZ1bmN0aW9uIHJlc29sdmUoZGlyMikge1xuICAgICAgdmFyIHR1cGxlcyA9IHJlYWRkaXJTeW5jKHBhdGguam9pbihkaXIyLCBcInByZWJ1aWxkc1wiKSkubWFwKHBhcnNlVHVwbGUpO1xuICAgICAgdmFyIHR1cGxlID0gdHVwbGVzLmZpbHRlcihtYXRjaFR1cGxlKHBsYXRmb3JtLCBhcmNoKSkuc29ydChjb21wYXJlVHVwbGVzKVswXTtcbiAgICAgIGlmICghdHVwbGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBwcmVidWlsZHMgPSBwYXRoLmpvaW4oZGlyMiwgXCJwcmVidWlsZHNcIiwgdHVwbGUubmFtZSk7XG4gICAgICB2YXIgcGFyc2VkID0gcmVhZGRpclN5bmMocHJlYnVpbGRzKS5tYXAocGFyc2VUYWdzKTtcbiAgICAgIHZhciBjYW5kaWRhdGVzID0gcGFyc2VkLmZpbHRlcihtYXRjaFRhZ3MocnVudGltZSwgYWJpKSk7XG4gICAgICB2YXIgd2lubmVyID0gY2FuZGlkYXRlcy5zb3J0KGNvbXBhcmVUYWdzKHJ1bnRpbWUpKVswXTtcbiAgICAgIGlmICh3aW5uZXIpXG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4ocHJlYnVpbGRzLCB3aW5uZXIuZmlsZSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiByZWFkZGlyU3luYyhkaXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKGRpcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldEZpcnN0KGRpciwgZmlsdGVyKSB7XG4gICAgdmFyIGZpbGVzID0gcmVhZGRpclN5bmMoZGlyKS5maWx0ZXIoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsZXNbMF0gJiYgcGF0aC5qb2luKGRpciwgZmlsZXNbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIG1hdGNoQnVpbGQobmFtZSkge1xuICAgIHJldHVybiAvXFwubm9kZSQvLnRlc3QobmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VUdXBsZShuYW1lKSB7XG4gICAgdmFyIGFyciA9IG5hbWUuc3BsaXQoXCItXCIpO1xuICAgIGlmIChhcnIubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBwbGF0Zm9ybTIgPSBhcnJbMF07XG4gICAgdmFyIGFyY2hpdGVjdHVyZXMgPSBhcnJbMV0uc3BsaXQoXCIrXCIpO1xuICAgIGlmICghcGxhdGZvcm0yKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYXJjaGl0ZWN0dXJlcy5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFhcmNoaXRlY3R1cmVzLmV2ZXJ5KEJvb2xlYW4pKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7IG5hbWUsIHBsYXRmb3JtOiBwbGF0Zm9ybTIsIGFyY2hpdGVjdHVyZXMgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaFR1cGxlKHBsYXRmb3JtMiwgYXJjaDIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odHVwbGUpIHtcbiAgICAgIGlmICh0dXBsZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodHVwbGUucGxhdGZvcm0gIT09IHBsYXRmb3JtMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHR1cGxlLmFyY2hpdGVjdHVyZXMuaW5jbHVkZXMoYXJjaDIpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZVR1cGxlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGEuYXJjaGl0ZWN0dXJlcy5sZW5ndGggLSBiLmFyY2hpdGVjdHVyZXMubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGFncyhmaWxlKSB7XG4gICAgdmFyIGFyciA9IGZpbGUuc3BsaXQoXCIuXCIpO1xuICAgIHZhciBleHRlbnNpb24yID0gYXJyLnBvcCgpO1xuICAgIHZhciB0YWdzID0geyBmaWxlLCBzcGVjaWZpY2l0eTogMCB9O1xuICAgIGlmIChleHRlbnNpb24yICE9PSBcIm5vZGVcIilcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhZyA9IGFycltpXTtcbiAgICAgIGlmICh0YWcgPT09IFwibm9kZVwiIHx8IHRhZyA9PT0gXCJlbGVjdHJvblwiIHx8IHRhZyA9PT0gXCJub2RlLXdlYmtpdFwiKSB7XG4gICAgICAgIHRhZ3MucnVudGltZSA9IHRhZztcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBcIm5hcGlcIikge1xuICAgICAgICB0YWdzLm5hcGkgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0YWcuc2xpY2UoMCwgMykgPT09IFwiYWJpXCIpIHtcbiAgICAgICAgdGFncy5hYmkgPSB0YWcuc2xpY2UoMyk7XG4gICAgICB9IGVsc2UgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gXCJ1dlwiKSB7XG4gICAgICAgIHRhZ3MudXYgPSB0YWcuc2xpY2UoMik7XG4gICAgICB9IGVsc2UgaWYgKHRhZy5zbGljZSgwLCA0KSA9PT0gXCJhcm12XCIpIHtcbiAgICAgICAgdGFncy5hcm12ID0gdGFnLnNsaWNlKDQpO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IFwiZ2xpYmNcIiB8fCB0YWcgPT09IFwibXVzbFwiKSB7XG4gICAgICAgIHRhZ3MubGliYyA9IHRhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGFncy5zcGVjaWZpY2l0eSsrO1xuICAgIH1cbiAgICByZXR1cm4gdGFncztcbiAgfVxuICBmdW5jdGlvbiBtYXRjaFRhZ3MocnVudGltZTIsIGFiaTIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFncykge1xuICAgICAgaWYgKHRhZ3MgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRhZ3MucnVudGltZSAhPT0gcnVudGltZTIgJiYgIXJ1bnRpbWVBZ25vc3RpYyh0YWdzKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRhZ3MuYWJpICE9PSBhYmkyICYmICF0YWdzLm5hcGkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0YWdzLnV2ICYmIHRhZ3MudXYgIT09IHV2KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGFncy5hcm12ICYmIHRhZ3MuYXJtdiAhPT0gYXJtdilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRhZ3MubGliYyAmJiB0YWdzLmxpYmMgIT09IGxpYmMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcnVudGltZUFnbm9zdGljKHRhZ3MpIHtcbiAgICByZXR1cm4gdGFncy5ydW50aW1lID09PSBcIm5vZGVcIiAmJiB0YWdzLm5hcGk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZVRhZ3MocnVudGltZTIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEucnVudGltZSAhPT0gYi5ydW50aW1lKSB7XG4gICAgICAgIHJldHVybiBhLnJ1bnRpbWUgPT09IHJ1bnRpbWUyID8gLTEgOiAxO1xuICAgICAgfSBlbHNlIGlmIChhLmFiaSAhPT0gYi5hYmkpIHtcbiAgICAgICAgcmV0dXJuIGEuYWJpID8gLTEgOiAxO1xuICAgICAgfSBlbHNlIGlmIChhLnNwZWNpZmljaXR5ICE9PSBiLnNwZWNpZmljaXR5KSB7XG4gICAgICAgIHJldHVybiBhLnNwZWNpZmljaXR5ID4gYi5zcGVjaWZpY2l0eSA/IC0xIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaXNOd2pzKCkge1xuICAgIHJldHVybiAhIShwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubncpO1xuICB9XG4gIGZ1bmN0aW9uIGlzRWxlY3Ryb24oKSB7XG4gICAgaWYgKHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbilcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5FTEVDVFJPTl9SVU5fQVNfTk9ERSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09IFwicmVuZGVyZXJcIjtcbiAgfVxuICBmdW5jdGlvbiBpc0FscGluZShwbGF0Zm9ybTIpIHtcbiAgICByZXR1cm4gcGxhdGZvcm0yID09PSBcImxpbnV4XCIgJiYgZnMuZXhpc3RzU3luYyhcIi9ldGMvYWxwaW5lLXJlbGVhc2VcIik7XG4gIH1cbiAgbG9hZC5wYXJzZVRhZ3MgPSBwYXJzZVRhZ3M7XG4gIGxvYWQubWF0Y2hUYWdzID0gbWF0Y2hUYWdzO1xuICBsb2FkLmNvbXBhcmVUYWdzID0gY29tcGFyZVRhZ3M7XG4gIGxvYWQucGFyc2VUdXBsZSA9IHBhcnNlVHVwbGU7XG4gIGxvYWQubWF0Y2hUdXBsZSA9IG1hdGNoVHVwbGU7XG4gIGxvYWQuY29tcGFyZVR1cGxlcyA9IGNvbXBhcmVUdXBsZXM7XG4gIHJldHVybiBub2RlR3lwQnVpbGQ7XG59XG52YXIgaGFzUmVxdWlyZWROb2RlR3lwQnVpbGQ7XG5mdW5jdGlvbiByZXF1aXJlTm9kZUd5cEJ1aWxkKCkge1xuICBpZiAoaGFzUmVxdWlyZWROb2RlR3lwQnVpbGQpXG4gICAgcmV0dXJuIG5vZGVHeXBCdWlsZCQxLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkTm9kZUd5cEJ1aWxkID0gMTtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzLmFkZG9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBub2RlR3lwQnVpbGQkMS5leHBvcnRzID0gcHJvY2Vzcy5hZGRvbi5iaW5kKHByb2Nlc3MpO1xuICB9IGVsc2Uge1xuICAgIG5vZGVHeXBCdWlsZCQxLmV4cG9ydHMgPSByZXF1aXJlTm9kZUd5cEJ1aWxkJDEoKTtcbiAgfVxuICByZXR1cm4gbm9kZUd5cEJ1aWxkJDEuZXhwb3J0cztcbn1cbnZhciBmYWxsYmFjaztcbnZhciBoYXNSZXF1aXJlZEZhbGxiYWNrO1xuZnVuY3Rpb24gcmVxdWlyZUZhbGxiYWNrKCkge1xuICBpZiAoaGFzUmVxdWlyZWRGYWxsYmFjaylcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIGhhc1JlcXVpcmVkRmFsbGJhY2sgPSAxO1xuICBjb25zdCBtYXNrMiA9IChzb3VyY2UsIG1hc2szLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFzazNbaSAmIDNdO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tYXNrMiA9IChidWZmZXIsIG1hc2szKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZmZXJbaV0gXj0gbWFzazNbaSAmIDNdO1xuICAgIH1cbiAgfTtcbiAgZmFsbGJhY2sgPSB7IG1hc2s6IG1hc2syLCB1bm1hc2s6IHVubWFzazIgfTtcbiAgcmV0dXJuIGZhbGxiYWNrO1xufVxudmFyIGhhc1JlcXVpcmVkQnVmZmVydXRpbDtcbmZ1bmN0aW9uIHJlcXVpcmVCdWZmZXJ1dGlsKCkge1xuICBpZiAoaGFzUmVxdWlyZWRCdWZmZXJ1dGlsKVxuICAgIHJldHVybiBidWZmZXJ1dGlsLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkQnVmZmVydXRpbCA9IDE7XG4gIHRyeSB7XG4gICAgYnVmZmVydXRpbC5leHBvcnRzID0gcmVxdWlyZU5vZGVHeXBCdWlsZCgpKF9fZGlybmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBidWZmZXJ1dGlsLmV4cG9ydHMgPSByZXF1aXJlRmFsbGJhY2soKTtcbiAgfVxuICByZXR1cm4gYnVmZmVydXRpbC5leHBvcnRzO1xufVxudmFyIHVubWFzayQxO1xudmFyIG1hc2s7XG5jb25zdCB7IEVNUFRZX0JVRkZFUjogRU1QVFlfQlVGRkVSJDMgfSA9IGNvbnN0YW50cztcbmNvbnN0IEZhc3RCdWZmZXIkMiA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5mdW5jdGlvbiBjb25jYXQkMShsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIEVNUFRZX0JVRkZFUiQzO1xuICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIGxpc3RbMF07XG4gIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlciQyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2syLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrMltpICYgM107XG4gIH1cbn1cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrMikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrMltpICYgM107XG4gIH1cbn1cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIkMShidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gdG9CdWZmZXIkMihkYXRhKSB7XG4gIHRvQnVmZmVyJDIucmVhZE9ubHkgPSB0cnVlO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKVxuICAgIHJldHVybiBkYXRhO1xuICBsZXQgYnVmO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIkMihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlciQyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIkMi5yZWFkT25seSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5idWZmZXJVdGlsJDEuZXhwb3J0cyA9IHtcbiAgY29uY2F0OiBjb25jYXQkMSxcbiAgbWFzazogX21hc2ssXG4gIHRvQXJyYXlCdWZmZXI6IHRvQXJyYXlCdWZmZXIkMSxcbiAgdG9CdWZmZXI6IHRvQnVmZmVyJDIsXG4gIHVubWFzazogX3VubWFza1xufTtcbmlmICghcHJvY2Vzcy5lbnYuV1NfTk9fQlVGRkVSX1VUSUwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXJVdGlsMiA9IHJlcXVpcmVCdWZmZXJ1dGlsKCk7XG4gICAgbWFzayA9IGJ1ZmZlclV0aWwkMS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbihzb3VyY2UsIG1hc2syLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpXG4gICAgICAgIF9tYXNrKHNvdXJjZSwgbWFzazIsIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZVxuICAgICAgICBidWZmZXJVdGlsMi5tYXNrKHNvdXJjZSwgbWFzazIsIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG4gICAgdW5tYXNrJDEgPSBidWZmZXJVdGlsJDEuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbihidWZmZXIsIG1hc2syKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKVxuICAgICAgICBfdW5tYXNrKGJ1ZmZlciwgbWFzazIpO1xuICAgICAgZWxzZVxuICAgICAgICBidWZmZXJVdGlsMi51bm1hc2soYnVmZmVyLCBtYXNrMik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG52YXIgYnVmZmVyVXRpbEV4cG9ydHMgPSBidWZmZXJVdGlsJDEuZXhwb3J0cztcbmNvbnN0IGtEb25lID0gU3ltYm9sKFwia0RvbmVcIik7XG5jb25zdCBrUnVuID0gU3ltYm9sKFwia1J1blwiKTtcbmxldCBMaW1pdGVyJDEgPSBjbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBqb2IgZnJvbSB0aGUgcXVldWUgYW5kIHJ1bnMgaXQgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBba1J1bl0oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG4gICAgICB0aGlzLnBlbmRpbmcrKztcbiAgICAgIGpvYih0aGlzW2tEb25lXSk7XG4gICAgfVxuICB9XG59O1xudmFyIGxpbWl0ZXIgPSBMaW1pdGVyJDE7XG5jb25zdCB6bGliID0gcmVxdWlyZSQkMCQyO1xuY29uc3QgYnVmZmVyVXRpbCA9IGJ1ZmZlclV0aWxFeHBvcnRzO1xuY29uc3QgTGltaXRlcjIgPSBsaW1pdGVyO1xuY29uc3QgeyBrU3RhdHVzQ29kZToga1N0YXR1c0NvZGUkMiB9ID0gY29uc3RhbnRzO1xuY29uc3QgRmFzdEJ1ZmZlciQxID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMCwgMCwgMjU1LCAyNTVdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbChcInBlcm1lc3NhZ2UtZGVmbGF0ZVwiKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbChcInRvdGFsLWxlbmd0aFwiKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbChcImNhbGxiYWNrXCIpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woXCJidWZmZXJzXCIpO1xuY29uc3Qga0Vycm9yJDEgPSBTeW1ib2woXCJlcnJvclwiKTtcbmxldCB6bGliTGltaXRlcjtcbmxldCBQZXJNZXNzYWdlRGVmbGF0ZSQ0ID0gY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9IHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB2b2lkIDAgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdm9pZCAwID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0IDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyMihjb25jdXJyZW5jeSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiBcInBlcm1lc3NhZ2UtZGVmbGF0ZVwiO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlciA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkXCJcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiYgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyIHx8IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8IHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IFwibnVtYmVyXCIgJiYgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpIHx8IHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IFwibnVtYmVyXCIgJiYgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkXCIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UpIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiYgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHwgdHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gXCJudW1iZXJcIiAmJiBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICBpZiAoa2V5ID09PSBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIikge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzXCIpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiIHx8IGtleSA9PT0gXCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlclwiKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gXCJjbGllbnRcIiA6IFwic2VydmVyXCI7XG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPSB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gXCJudW1iZXJcIiA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFMgOiB0aGlzLnBhcmFtc1trZXldO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oXCJlcnJvclwiLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKFwiZGF0YVwiLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKVxuICAgICAgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yJDFdO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhMiA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhMik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/IFwic2VydmVyXCIgOiBcImNsaWVudFwiO1xuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID0gdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09IFwibnVtYmVyXCIgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTIDogdGhpcy5wYXJhbXNba2V5XTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2RlZmxhdGUub24oXCJkYXRhXCIsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGF0YTIgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcbiAgICAgIGlmIChmaW4pIHtcbiAgICAgICAgZGF0YTIgPSBuZXcgRmFzdEJ1ZmZlciQxKGRhdGEyLmJ1ZmZlciwgZGF0YTIuYnl0ZU9mZnNldCwgZGF0YTIubGVuZ3RoIC0gNCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YTIpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHBlcm1lc3NhZ2VEZWZsYXRlID0gUGVyTWVzc2FnZURlZmxhdGUkNDtcbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG4gIGlmICh0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8IHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQpIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpc1trRXJyb3IkMV0gPSBuZXcgUmFuZ2VFcnJvcihcIk1heCBwYXlsb2FkIHNpemUgZXhjZWVkZWRcIik7XG4gIHRoaXNba0Vycm9yJDFdLmNvZGUgPSBcIldTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSFwiO1xuICB0aGlzW2tFcnJvciQxXVtrU3RhdHVzQ29kZSQyXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlJDJdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG52YXIgdmFsaWRhdGlvbiA9IHsgZXhwb3J0czoge30gfTtcbmNvbnN0IF9fdml0ZU9wdGlvbmFsUGVlckRlcF91dGY4VmFsaWRhdGVfd3MgPSB7fTtcbmNvbnN0IF9fdml0ZU9wdGlvbmFsUGVlckRlcF91dGY4VmFsaWRhdGVfd3MkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IF9fdml0ZU9wdGlvbmFsUGVlckRlcF91dGY4VmFsaWRhdGVfd3Ncbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5jb25zdCByZXF1aXJlJCQxID0gLyogQF9fUFVSRV9fICovIGdldEF1Z21lbnRlZE5hbWVzcGFjZShfX3ZpdGVPcHRpb25hbFBlZXJEZXBfdXRmOFZhbGlkYXRlX3dzJDEpO1xudmFyIGlzVmFsaWRVVEY4XzE7XG5jb25zdCB7IGlzVXRmOCB9ID0gcmVxdWlyZSQkMCQzO1xuY29uc3QgdG9rZW5DaGFycyQyID0gW1xuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAvLyAwIC0gMTVcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgLy8gMTYgLSAzMVxuICAwLFxuICAxLFxuICAwLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAwLFxuICAwLFxuICAxLFxuICAxLFxuICAwLFxuICAxLFxuICAxLFxuICAwLFxuICAvLyAzMiAtIDQ3XG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIC8vIDQ4IC0gNjNcbiAgMCxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgLy8gNjQgLSA3OVxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAwLFxuICAwLFxuICAwLFxuICAxLFxuICAxLFxuICAvLyA4MCAtIDk1XG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIC8vIDk2IC0gMTExXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDAsXG4gIDEsXG4gIDAsXG4gIDEsXG4gIDBcbiAgLy8gMTEyIC0gMTI3XG5dO1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUkMihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDFlMyAmJiBjb2RlIDw9IDEwMTQgJiYgY29kZSAhPT0gMTAwNCAmJiBjb2RlICE9PSAxMDA1ICYmIGNvZGUgIT09IDEwMDYgfHwgY29kZSA+PSAzZTMgJiYgY29kZSA8PSA0OTk5O1xufVxuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAxMjgpID09PSAwKSB7XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMjI0KSA9PT0gMTkyKSB7XG4gICAgICBpZiAoaSArIDEgPT09IGxlbiB8fCAoYnVmW2kgKyAxXSAmIDE5MikgIT09IDEyOCB8fCAoYnVmW2ldICYgMjU0KSA9PT0gMTkyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAyNDApID09PSAyMjQpIHtcbiAgICAgIGlmIChpICsgMiA+PSBsZW4gfHwgKGJ1ZltpICsgMV0gJiAxOTIpICE9PSAxMjggfHwgKGJ1ZltpICsgMl0gJiAxOTIpICE9PSAxMjggfHwgYnVmW2ldID09PSAyMjQgJiYgKGJ1ZltpICsgMV0gJiAyMjQpID09PSAxMjggfHwgLy8gT3ZlcmxvbmdcbiAgICAgIGJ1ZltpXSA9PT0gMjM3ICYmIChidWZbaSArIDFdICYgMjI0KSA9PT0gMTYwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAyNDgpID09PSAyNDApIHtcbiAgICAgIGlmIChpICsgMyA+PSBsZW4gfHwgKGJ1ZltpICsgMV0gJiAxOTIpICE9PSAxMjggfHwgKGJ1ZltpICsgMl0gJiAxOTIpICE9PSAxMjggfHwgKGJ1ZltpICsgM10gJiAxOTIpICE9PSAxMjggfHwgYnVmW2ldID09PSAyNDAgJiYgKGJ1ZltpICsgMV0gJiAyNDApID09PSAxMjggfHwgLy8gT3ZlcmxvbmdcbiAgICAgIGJ1ZltpXSA9PT0gMjQ0ICYmIGJ1ZltpICsgMV0gPiAxNDMgfHwgYnVmW2ldID4gMjQ0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhbGlkYXRpb24uZXhwb3J0cyA9IHtcbiAgaXNWYWxpZFN0YXR1c0NvZGU6IGlzVmFsaWRTdGF0dXNDb2RlJDIsXG4gIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG4gIHRva2VuQ2hhcnM6IHRva2VuQ2hhcnMkMlxufTtcbmlmIChpc1V0ZjgpIHtcbiAgaXNWYWxpZFVURjhfMSA9IHZhbGlkYXRpb24uZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHJldHVybiBidWYubGVuZ3RoIDwgMjQgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVXRmOChidWYpO1xuICB9O1xufSBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpc1ZhbGlkVVRGODIgPSByZXF1aXJlJCQxO1xuICAgIGlzVmFsaWRVVEY4XzEgPSB2YWxpZGF0aW9uLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbihidWYpIHtcbiAgICAgIHJldHVybiBidWYubGVuZ3RoIDwgMzIgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4MihidWYpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxudmFyIHZhbGlkYXRpb25FeHBvcnRzID0gdmFsaWRhdGlvbi5leHBvcnRzO1xuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSQkMDtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlJDMgPSBwZXJtZXNzYWdlRGVmbGF0ZTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTOiBCSU5BUllfVFlQRVMkMSxcbiAgRU1QVFlfQlVGRkVSOiBFTVBUWV9CVUZGRVIkMixcbiAga1N0YXR1c0NvZGU6IGtTdGF0dXNDb2RlJDEsXG4gIGtXZWJTb2NrZXQ6IGtXZWJTb2NrZXQkMlxufSA9IGNvbnN0YW50cztcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IGJ1ZmZlclV0aWxFeHBvcnRzO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZTogaXNWYWxpZFN0YXR1c0NvZGUkMSwgaXNWYWxpZFVURjggfSA9IHZhbGlkYXRpb25FeHBvcnRzO1xuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5sZXQgUmVjZWl2ZXIkMSA9IGNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5iaW5hcnlUeXBlPW5vZGVidWZmZXJdIFRoZSB0eXBlIGZvciBiaW5hcnkgZGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWRcbiAgICogICAgIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpblxuICAgKiAgICAgY2xpZW50IG9yIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFUyQxWzBdO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBvcHRpb25zLmV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIW9wdGlvbnMuaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG9wdGlvbnMubWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uID0gISFvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbjtcbiAgICB0aGlzW2tXZWJTb2NrZXQkMl0gPSB2b2lkIDA7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTylcbiAgICAgIHJldHVybiBjYigpO1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICBidWYuYnl0ZU9mZnNldCArIG4sXG4gICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICBjb25zdCBvZmZzZXQgPSBkc3QubGVuZ3RoIC0gbjtcbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuICAgIHJldHVybiBkc3Q7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzY0OlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0UGF5bG9hZExlbmd0aDY0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuICAgIGNiKGVycik7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBmaXJzdCB0d28gYnl0ZXMgb2YgYSBmcmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuICAgIGlmICgoYnVmWzBdICYgNDgpICE9PSAwKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIFwiUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyXCIsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgIFwiV1NfRVJSX1VORVhQRUNURURfUlNWXzJfM1wiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDY0KSA9PT0gNjQ7XG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMy5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBcIlJTVjEgbXVzdCBiZSBjbGVhclwiLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICBcIldTX0VSUl9VTkVYUEVDVEVEX1JTVl8xXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAxMjgpID09PSAxMjg7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMTU7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDEyNztcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIFwiUlNWMSBtdXN0IGJlIGNsZWFyXCIsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgIFwiV1NfRVJSX1VORVhQRUNURURfUlNWXzFcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgXCJpbnZhbGlkIG9wY29kZSAwXCIsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgIFwiV1NfRVJSX0lOVkFMSURfT1BDT0RFXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX29wY29kZSA9IHRoaXMuX2ZyYWdtZW50ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPT09IDEgfHwgdGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICBpZiAodGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICBcIldTX0VSUl9JTlZBTElEX09QQ09ERVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDcgJiYgdGhpcy5fb3Bjb2RlIDwgMTEpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgXCJGSU4gbXVzdCBiZSBzZXRcIixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgXCJXU19FUlJfRVhQRUNURURfRklOXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgXCJSU1YxIG11c3QgYmUgY2xlYXJcIixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgXCJXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA+IDEyNSB8fCB0aGlzLl9vcGNvZGUgPT09IDggJiYgdGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICBcIldTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEhcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICBcIldTX0VSUl9JTlZBTElEX09QQ09ERVwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZClcbiAgICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSB0aGlzLl9vcGNvZGU7XG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDEyOCkgPT09IDEyODtcbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgXCJNQVNLIG11c3QgYmUgc2V0XCIsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgIFwiV1NfRVJSX0VYUEVDVEVEX01BU0tcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIFwiTUFTSyBtdXN0IGJlIGNsZWFyXCIsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgIFwiV1NfRVJSX1VORVhQRUNURURfTUFTS1wiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KVxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KVxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2KCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSg4KTtcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgXCJVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDFcIixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgIFwiV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEhcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKCkge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBcIk1heCBwYXlsb2FkIHNpemUgZXhjZWVkZWRcIixcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgIFwiV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX21hc2tlZClcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSJDI7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkICYmICh0aGlzLl9tYXNrWzBdIHwgdGhpcy5fbWFza1sxXSB8IHRoaXMuX21hc2tbMl0gfCB0aGlzLl9tYXNrWzNdKSAhPT0gMCkge1xuICAgICAgICB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiA3KVxuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSk7XG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFNZXNzYWdlKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMy5leHRlbnNpb25OYW1lXTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKVxuICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgIFwiTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZFwiLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICAgXCJXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEhcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2Zpbikge1xuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuICAgICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICBcImludmFsaWQgVVRGLTggc2VxdWVuY2VcIixcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgXCJXU19FUlJfSU5WQUxJRF9VVEY4XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgYnVmLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29uY2x1ZGVcIiwgMTAwNSwgRU1QVFlfQlVGRkVSJDIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuICAgICAgICBpZiAoIWlzVmFsaWRTdGF0dXNDb2RlJDEoY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwMixcbiAgICAgICAgICAgIFwiV1NfRVJSX0lOVkFMSURfQ0xPU0VfQ09ERVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgXCJpbnZhbGlkIFVURi04IHNlcXVlbmNlXCIsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgIFwiV1NfRVJSX0lOVkFMSURfVVRGOFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJjb25jbHVkZVwiLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSA5KSB7XG4gICAgICB0aGlzLmVtaXQoXCJwaW5nXCIsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoXCJwb25nXCIsIGRhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG59O1xudmFyIHJlY2VpdmVyID0gUmVjZWl2ZXIkMTtcbmZ1bmN0aW9uIGVycm9yKEVycm9yQ3RvciwgbWVzc2FnZSwgcHJlZml4LCBzdGF0dXNDb2RlLCBlcnJvckNvZGUpIHtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuICApO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGVycm9yKTtcbiAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gIGVycltrU3RhdHVzQ29kZSQxXSA9IHN0YXR1c0NvZGU7XG4gIHJldHVybiBlcnI7XG59XG5jb25zdCByZWNlaXZlciQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHJlY2VpdmVyKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUkJDU7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSQyID0gcGVybWVzc2FnZURlZmxhdGU7XG5jb25zdCB7IEVNUFRZX0JVRkZFUjogRU1QVFlfQlVGRkVSJDEgfSA9IGNvbnN0YW50cztcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHZhbGlkYXRpb25FeHBvcnRzO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyOiB0b0J1ZmZlciQxIH0gPSBidWZmZXJVdGlsRXhwb3J0cztcbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKFwia0J5dGVMZW5ndGhcIik7XG5jb25zdCBtYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xubGV0IFNlbmRlciQxID0gY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgaWYgKGdlbmVyYXRlTWFzaykge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVNYXNrID0gZ2VuZXJhdGVNYXNrO1xuICAgICAgdGhpcy5fbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICB9XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrMjtcbiAgICBsZXQgbWVyZ2UgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgc2tpcE1hc2tpbmcgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrMiA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVNYXNrKSB7XG4gICAgICAgIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKG1hc2syKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmRvbUZpbGxTeW5jKG1hc2syLCAwLCA0KTtcbiAgICAgIH1cbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2syWzBdIHwgbWFzazJbMV0gfCBtYXNrMlsyXSB8IG1hc2syWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuICAgIGxldCBkYXRhTGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJiBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBtZXJnZSA9IG9wdGlvbnMubWFzayAmJiBvcHRpb25zLnJlYWRPbmx5ICYmICFza2lwTWFza2luZztcbiAgICB9XG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXJnZSA/IGRhdGFMZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAxMjggOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKVxuICAgICAgdGFyZ2V0WzBdIHw9IDY0O1xuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5tYXNrKVxuICAgICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICAgIHRhcmdldFsxXSB8PSAxMjg7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFzazJbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFzazJbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFzazJbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFzazJbM107XG4gICAgaWYgKHNraXBNYXNraW5nKVxuICAgICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2syLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrMiwgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2syLCBjYikge1xuICAgIGxldCBidWY7XG4gICAgaWYgKGNvZGUgPT09IHZvaWQgMCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSJDE7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gXCJudW1iZXJcIiB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB2b2lkIDAgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlc1wiKTtcbiAgICAgIH1cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBidWYubGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBtYXNrMixcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDgsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBidWYsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzazIsIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyJDEoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyJDEucmVhZE9ubHk7XG4gICAgfVxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2s6IG1hc2syLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogOSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBwb25nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzazIsIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyJDEoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyJDEucmVhZE9ubHk7XG4gICAgfVxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2s6IG1hc2syLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMTAsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeVxuICAgKiAgICAgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZSQyLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIkMShkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIkMS5yZWFkT25seTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChyc3YxICYmIHBlck1lc3NhZ2VEZWZsYXRlICYmIHBlck1lc3NhZ2VEZWZsYXRlLnBhcmFtc1twZXJNZXNzYWdlRGVmbGF0ZS5faXNTZXJ2ZXIgPyBcInNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyXCIgOiBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCJdKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbilcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICByZWFkT25seSxcbiAgICAgICAgcnN2MVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICByZWFkT25seSxcbiAgICAgICAgICByc3YxOiBmYWxzZVxuICAgICAgICB9KSxcbiAgICAgICAgY2JcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMi5leHRlbnNpb25OYW1lXTtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IHRydWU7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRoZSBzb2NrZXQgd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBjb21wcmVzc2VkXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIGNiKGVycik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9xdWV1ZVtpXTtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzZW5kIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFNlbmQgb3BlcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlKHBhcmFtcykge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn07XG52YXIgc2VuZGVyID0gU2VuZGVyJDE7XG5jb25zdCBzZW5kZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZW5kZXIpO1xuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZToga0Zvck9uRXZlbnRBdHRyaWJ1dGUkMSwga0xpc3RlbmVyOiBrTGlzdGVuZXIkMSB9ID0gY29uc3RhbnRzO1xuY29uc3Qga0NvZGUgPSBTeW1ib2woXCJrQ29kZVwiKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKFwia0RhdGFcIik7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woXCJrRXJyb3JcIik7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbChcImtNZXNzYWdlXCIpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbChcImtSZWFzb25cIik7XG5jb25zdCBrVGFyZ2V0ID0gU3ltYm9sKFwia1RhcmdldFwiKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKFwia1R5cGVcIik7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woXCJrV2FzQ2xlYW5cIik7XG5jbGFzcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGB0eXBlYCBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpc1trVGFyZ2V0XSA9IG51bGw7XG4gICAgdGhpc1trVHlwZV0gPSB0eXBlO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29kZT0wXSBUaGUgc3RhdHVzIGNvZGUgZXhwbGFpbmluZyB3aHkgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJlYXNvbj0nJ10gQSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZXhwbGFpbmluZyB3aHlcbiAgICogICAgIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53YXNDbGVhbj1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xlYW5seSBjbG9zZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB2b2lkIDAgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdm9pZCAwID8gXCJcIiA6IG9wdGlvbnMucmVhc29uO1xuICAgIHRoaXNba1dhc0NsZWFuXSA9IG9wdGlvbnMud2FzQ2xlYW4gPT09IHZvaWQgMCA/IGZhbHNlIDogb3B0aW9ucy53YXNDbGVhbjtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHdhc0NsZWFuKCkge1xuICAgIHJldHVybiB0aGlzW2tXYXNDbGVhbl07XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgXCJjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgXCJyZWFzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCBcIndhc0NsZWFuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcbiAgICB0aGlzW2tFcnJvcl0gPSBvcHRpb25zLmVycm9yID09PSB2b2lkIDAgPyBudWxsIDogb3B0aW9ucy5lcnJvcjtcbiAgICB0aGlzW2tNZXNzYWdlXSA9IG9wdGlvbnMubWVzc2FnZSA9PT0gdm9pZCAwID8gXCJcIiA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZXJyb3IoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Vycm9yXTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbmNsYXNzIE1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgTWVzc2FnZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmRhdGE9bnVsbF0gVGhlIG1lc3NhZ2UgY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHZvaWQgMCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKCFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlJDFdICYmIGxpc3RlbmVyW2tMaXN0ZW5lciQxXSA9PT0gaGFuZGxlciAmJiAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGUkMV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd3JhcHBlcjtcbiAgICBpZiAodHlwZSA9PT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb246IG1lc3NhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25FcnJvcihlcnJvcjIpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgICBlcnJvcjogZXJyb3IyLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yMi5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk9wZW4oKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KFwib3BlblwiKTtcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlJDFdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlJDFdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyJDFdID0gaGFuZGxlcjtcbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKHR5cGUpKSB7XG4gICAgICBpZiAobGlzdGVuZXJba0xpc3RlbmVyJDFdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZSQxXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGV2ZW50VGFyZ2V0ID0ge1xuICBDbG9zZUV2ZW50LFxuICBFcnJvckV2ZW50LFxuICBFdmVudCxcbiAgRXZlbnRUYXJnZXQsXG4gIE1lc3NhZ2VFdmVudFxufTtcbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJvYmplY3RcIiAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcbiAgfVxufVxuY29uc3QgeyB0b2tlbkNoYXJzOiB0b2tlbkNoYXJzJDEgfSA9IHZhbGlkYXRpb25FeHBvcnRzO1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB2b2lkIDApXG4gICAgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZVxuICAgIGRlc3RbbmFtZV0ucHVzaChlbGVtKTtcbn1cbmZ1bmN0aW9uIHBhcnNlJDIoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgcGFyYW1zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChleHRlbnNpb25OYW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnMkMVtjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoaSAhPT0gMCAmJiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKVxuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDU5IHx8IGNvZGUgPT09IDQ0KSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDQpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFycyQxW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSA5KSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSlcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSA1OSB8fCBjb2RlID09PSA0NCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0NCkge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNjEgJiYgc3RhcnQgIT09IC0xICYmIGVuZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyYW1OYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNFc2NhcGluZykge1xuICAgICAgICBpZiAodG9rZW5DaGFycyQxW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSlcbiAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpXG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgaXNFc2NhcGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpblF1b3Rlcykge1xuICAgICAgICBpZiAodG9rZW5DaGFycyQxW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSlcbiAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAzNCAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gOTIpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAzNCAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDYxKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzJDFbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSlcbiAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNTkgfHwgY29kZSA9PT0gNDQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXC9nLCBcIlwiKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0NCkge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1OYW1lID0gdm9pZCAwO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzdGFydCA9PT0gLTEgfHwgaW5RdW90ZXMgfHwgY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gOSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xuICB9XG4gIGlmIChlbmQgPT09IC0xKVxuICAgIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCBcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuIG9mZmVycztcbn1cbmZ1bmN0aW9uIGZvcm1hdCQxKGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLm1hcCgoZXh0ZW5zaW9uMikgPT4ge1xuICAgIGxldCBjb25maWd1cmF0aW9ucyA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSlcbiAgICAgIGNvbmZpZ3VyYXRpb25zID0gW2NvbmZpZ3VyYXRpb25zXTtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnMubWFwKChwYXJhbXMpID0+IHtcbiAgICAgIHJldHVybiBbZXh0ZW5zaW9uMl0uY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpXG4gICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCgodikgPT4gdiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkuam9pbihcIjsgXCIpO1xuICAgICAgICB9KVxuICAgICAgKS5qb2luKFwiOyBcIik7XG4gICAgfSkuam9pbihcIiwgXCIpO1xuICB9KS5qb2luKFwiLCBcIik7XG59XG52YXIgZXh0ZW5zaW9uJDEgPSB7IGZvcm1hdDogZm9ybWF0JDEsIHBhcnNlOiBwYXJzZSQyIH07XG5jb25zdCBFdmVudEVtaXR0ZXIkMSA9IHJlcXVpcmUkJDAkNDtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSQkMSQyO1xuY29uc3QgaHR0cCQxID0gcmVxdWlyZSQkMiQxO1xuY29uc3QgbmV0ID0gcmVxdWlyZSQkMztcbmNvbnN0IHRscyA9IHJlcXVpcmUkJDQ7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoOiBjcmVhdGVIYXNoJDEgfSA9IHJlcXVpcmUkJDU7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSQkNztcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlJDEgPSBwZXJtZXNzYWdlRGVmbGF0ZTtcbmNvbnN0IFJlY2VpdmVyMiA9IHJlY2VpdmVyO1xuY29uc3QgU2VuZGVyMiA9IHNlbmRlcjtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQ6IEdVSUQkMSxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQ6IGtXZWJTb2NrZXQkMSxcbiAgTk9PUFxufSA9IGNvbnN0YW50cztcbmNvbnN0IHtcbiAgRXZlbnRUYXJnZXQ6IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9XG59ID0gZXZlbnRUYXJnZXQ7XG5jb25zdCB7IGZvcm1hdCwgcGFyc2U6IHBhcnNlJDEgfSA9IGV4dGVuc2lvbiQxO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gYnVmZmVyVXRpbEV4cG9ydHM7XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDFlMztcbmNvbnN0IGtBYm9ydGVkID0gU3ltYm9sKFwia0Fib3J0ZWRcIik7XG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IHJlYWR5U3RhdGVzID0gW1wiQ09OTkVDVElOR1wiLCBcIk9QRU5cIiwgXCJDTE9TSU5HXCIsIFwiQ0xPU0VEXCJdO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcbmxldCBXZWJTb2NrZXQkMSA9IGNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciQxIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgV2ViU29ja2V0YC5cbiAgICpcbiAgICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xTdHJpbmdbXSl9IFtwcm90b2NvbHNdIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9IFwiXCI7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gbnVsbDtcbiAgICB0aGlzLl9zZW5kZXIgPSBudWxsO1xuICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuICAgICAgaWYgKHByb3RvY29scyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSBcIm9iamVjdFwiICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIGRldmlhdGVzIGZyb20gdGhlIFdIQVRXRyBpbnRlcmZhY2Ugc2luY2Ugd3MgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgKiByZXF1aXJlZCBkZWZhdWx0IFwiYmxvYlwiIHR5cGUgKGluc3RlYWQgd2UgZGVmaW5lIGEgY3VzdG9tIFwibm9kZWJ1ZmZlclwiXG4gICAqIHR5cGUpLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cbiAgc2V0IGJpbmFyeVR5cGUodHlwZSkge1xuICAgIGlmICghQklOQVJZX1RZUEVTLmluY2x1ZGVzKHR5cGUpKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcilcbiAgICAgIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldClcbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBleHRlbnNpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9leHRlbnNpb25zKS5qb2luKCk7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25lcnJvcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlY2VpdmVyMiA9IG5ldyBSZWNlaXZlcjIoe1xuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgICB0aGlzLl9zZW5kZXIgPSBuZXcgU2VuZGVyMihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyMjtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgcmVjZWl2ZXIyW2tXZWJTb2NrZXQkMV0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0JDFdID0gdGhpcztcbiAgICByZWNlaXZlcjIub24oXCJjb25jbHVkZVwiLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyMi5vbihcImRyYWluXCIsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIyLm9uKFwiZXJyb3JcIiwgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlcjIub24oXCJtZXNzYWdlXCIsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlcjIub24oXCJwaW5nXCIsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlcjIub24oXCJwb25nXCIsIHJlY2VpdmVyT25Qb25nKTtcbiAgICBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBzb2NrZXQuc2V0Tm9EZWxheSgpO1xuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApXG4gICAgICBzb2NrZXQudW5zaGlmdChoZWFkKTtcbiAgICBzb2NrZXQub24oXCJjbG9zZVwiLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oXCJkYXRhXCIsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKFwiZW5kXCIsIHNvY2tldE9uRW5kKTtcbiAgICBzb2NrZXQub24oXCJlcnJvclwiLCBzb2NrZXRPbkVycm9yJDEpO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICB9XG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZSQxLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlJDEuZXh0ZW5zaW9uTmFtZV0uY2xlYW51cCgpO1xuICAgIH1cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCB0aGlzLl9jbG9zZUNvZGUsIHRoaXMuX2Nsb3NlTWVzc2FnZSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gXCJXZWJTb2NrZXQgd2FzIGNsb3NlZCBiZWZvcmUgdGhlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkXCI7XG4gICAgICBhYm9ydEhhbmRzaGFrZSQxKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmICh0aGlzLl9jbG9zZUZyYW1lU2VudCAmJiAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3kuYmluZCh0aGlzLl9zb2NrZXQpLFxuICAgICAgY2xvc2VUaW1lb3V0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUGF1c2UgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0LnBhdXNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2syLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORylcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzazIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzazIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBtYXNrMjtcbiAgICAgIG1hc2syID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpXG4gICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXNrMiA9PT0gdm9pZCAwKVxuICAgICAgbWFzazIgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2syLCBjYik7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2syLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORylcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzazIgPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzazIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBtYXNrMjtcbiAgICAgIG1hc2syID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpXG4gICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXNrMiA9PT0gdm9pZCAwKVxuICAgICAgbWFzazIgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2syLCBjYik7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpXG4gICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiLFxuICAgICAgbWFzazogIXRoaXMuX2lzU2VydmVyLFxuICAgICAgY29tcHJlc3M6IHRydWUsXG4gICAgICBmaW46IHRydWUsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZFwiO1xuICAgICAgYWJvcnRIYW5kc2hha2UkMSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCQxLCBcIkNPTk5FQ1RJTkdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZihcIkNPTk5FQ1RJTkdcIilcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCQxLnByb3RvdHlwZSwgXCJDT05ORUNUSU5HXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoXCJDT05ORUNUSU5HXCIpXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMSwgXCJPUEVOXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoXCJPUEVOXCIpXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMS5wcm90b3R5cGUsIFwiT1BFTlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKFwiT1BFTlwiKVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0JDEsIFwiQ0xPU0lOR1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKFwiQ0xPU0lOR1wiKVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0JDEucHJvdG90eXBlLCBcIkNMT1NJTkdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZihcIkNMT1NJTkdcIilcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCQxLCBcIkNMT1NFRFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKFwiQ0xPU0VEXCIpXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMS5wcm90b3R5cGUsIFwiQ0xPU0VEXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoXCJDTE9TRURcIilcbn0pO1xuW1xuICBcImJpbmFyeVR5cGVcIixcbiAgXCJidWZmZXJlZEFtb3VudFwiLFxuICBcImV4dGVuc2lvbnNcIixcbiAgXCJpc1BhdXNlZFwiLFxuICBcInByb3RvY29sXCIsXG4gIFwicmVhZHlTdGF0ZVwiLFxuICBcInVybFwiXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMS5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59KTtcbltcIm9wZW5cIiwgXCJlcnJvclwiLCBcImNsb3NlXCIsIFwibWVzc2FnZVwiXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCQxLnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pXG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcbldlYlNvY2tldCQxLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldCQxLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbnZhciB3ZWJzb2NrZXQgPSBXZWJTb2NrZXQkMTtcbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQyLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdHJ1ZSxcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBjcmVhdGVDb25uZWN0aW9uOiB2b2lkIDAsXG4gICAgc29ja2V0UGF0aDogdm9pZCAwLFxuICAgIGhvc3RuYW1lOiB2b2lkIDAsXG4gICAgcHJvdG9jb2w6IHZvaWQgMCxcbiAgICB0aW1lb3V0OiB2b2lkIDAsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhvc3Q6IHZvaWQgMCxcbiAgICBwYXRoOiB2b2lkIDAsXG4gICAgcG9ydDogdm9pZCAwXG4gIH07XG4gIGlmICghcHJvdG9jb2xWZXJzaW9ucy5pbmNsdWRlcyhvcHRzLnByb3RvY29sVmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgIGBVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke29wdHMucHJvdG9jb2xWZXJzaW9ufSAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbihcIiwgXCIpfSlgXG4gICAgKTtcbiAgfVxuICBsZXQgcGFyc2VkVXJsO1xuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0Mi5fdXJsID0gYWRkcmVzcy5ocmVmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBwYXJzZWRVcmwgPSBuZXcgVVJMKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgd2Vic29ja2V0Mi5fdXJsID0gYWRkcmVzcztcbiAgfVxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJ3c3M6XCI7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSBcIndzK3VuaXg6XCI7XG4gIGxldCBpbnZhbGlkVXJsTWVzc2FnZTtcbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gXCJ3czpcIiAmJiAhaXNTZWN1cmUgJiYgIWlzSXBjVXJsKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBgVGhlIFVSTCdzIHByb3RvY29sIG11c3QgYmUgb25lIG9mIFwid3M6XCIsIFwid3NzOlwiLCBvciBcIndzK3VuaXg6XCJgO1xuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCBjb250YWlucyBhIGZyYWdtZW50IGlkZW50aWZpZXJcIjtcbiAgfVxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVybE1lc3NhZ2UpO1xuICAgIGlmICh3ZWJzb2NrZXQyLl9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0MiwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVmYXVsdFBvcnQgPSBpc1NlY3VyZSA/IDQ0MyA6IDgwO1xuICBjb25zdCBrZXkgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwJDEucmVxdWVzdDtcbiAgY29uc3QgcHJvdG9jb2xTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9IGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3Q7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoXCJbXCIpID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKSA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICBcIlNlYy1XZWJTb2NrZXQtVmVyc2lvblwiOiBvcHRzLnByb3RvY29sVmVyc2lvbixcbiAgICBcIlNlYy1XZWJTb2NrZXQtS2V5XCI6IGtleSxcbiAgICBDb25uZWN0aW9uOiBcIlVwZ3JhZGVcIixcbiAgICBVcGdyYWRlOiBcIndlYnNvY2tldFwiXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZSQxKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbXCJTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNcIl0gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlJDEuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvY29sICE9PSBcInN0cmluZ1wiIHx8ICFzdWJwcm90b2NvbFJlZ2V4LnRlc3QocHJvdG9jb2wpIHx8IHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIFwiQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvdG9jb2xTZXQuYWRkKHByb3RvY29sKTtcbiAgICB9XG4gICAgb3B0cy5oZWFkZXJzW1wiU2VjLVdlYlNvY2tldC1Qcm90b2NvbFwiXSA9IHByb3RvY29scy5qb2luKFwiLFwiKTtcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzW1wiU2VjLVdlYlNvY2tldC1PcmlnaW5cIl0gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuICBpZiAoaXNJcGNVcmwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG9wdHMucGF0aC5zcGxpdChcIjpcIik7XG4gICAgb3B0cy5zb2NrZXRQYXRoID0gcGFydHNbMF07XG4gICAgb3B0cy5wYXRoID0gcGFydHNbMV07XG4gIH1cbiAgbGV0IHJlcTtcbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldDIuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgd2Vic29ja2V0Mi5fb3JpZ2luYWxJcGMgPSBpc0lwY1VybDtcbiAgICAgIHdlYnNvY2tldDIuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQyLl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGggPSBpc0lwY1VybCA/IG9wdHMuc29ja2V0UGF0aCA6IHBhcnNlZFVybC5ob3N0O1xuICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzO1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgaGVhZGVyczoge30gfTtcbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleTIsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1trZXkyLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdlYnNvY2tldDIubGlzdGVuZXJDb3VudChcInJlZGlyZWN0XCIpID09PSAwKSB7XG4gICAgICBjb25zdCBpc1NhbWVIb3N0ID0gaXNJcGNVcmwgPyB3ZWJzb2NrZXQyLl9vcmlnaW5hbElwYyA/IG9wdHMuc29ja2V0UGF0aCA9PT0gd2Vic29ja2V0Mi5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoIDogZmFsc2UgOiB3ZWJzb2NrZXQyLl9vcmlnaW5hbElwYyA/IGZhbHNlIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldDIuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aDtcbiAgICAgIGlmICghaXNTYW1lSG9zdCB8fCB3ZWJzb2NrZXQyLl9vcmlnaW5hbFNlY3VyZSAmJiAhaXNTZWN1cmUpIHtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmNvb2tpZTtcbiAgICAgICAgaWYgKCFpc1NhbWVIb3N0KVxuICAgICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdDtcbiAgICAgICAgb3B0cy5hdXRoID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5hdXRoICYmICFvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSBcIkJhc2ljIFwiICsgQnVmZmVyLmZyb20ob3B0cy5hdXRoKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgcmVxID0gd2Vic29ja2V0Mi5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgICBpZiAod2Vic29ja2V0Mi5fcmVkaXJlY3RzKSB7XG4gICAgICB3ZWJzb2NrZXQyLmVtaXQoXCJyZWRpcmVjdFwiLCB3ZWJzb2NrZXQyLnVybCwgcmVxKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gd2Vic29ja2V0Mi5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgfVxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSQxKHdlYnNvY2tldDIsIHJlcSwgXCJPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0XCIpO1xuICAgIH0pO1xuICB9XG4gIHJlcS5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcVtrQWJvcnRlZF0pXG4gICAgICByZXR1cm47XG4gICAgcmVxID0gd2Vic29ja2V0Mi5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQyLCBlcnIpO1xuICB9KTtcbiAgcmVxLm9uKFwicmVzcG9uc2VcIiwgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgIGlmIChsb2NhdGlvbiAmJiBvcHRzLmZvbGxvd1JlZGlyZWN0cyAmJiBzdGF0dXNDb2RlID49IDMwMCAmJiBzdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQyLl9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSQxKHdlYnNvY2tldDIsIHJlcSwgXCJNYXhpbXVtIHJlZGlyZWN0cyBleGNlZWRlZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVxLmFib3J0KCk7XG4gICAgICBsZXQgYWRkcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHtsb2NhdGlvbn1gKTtcbiAgICAgICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0MiwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldDIsIGFkZHIsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICghd2Vic29ja2V0Mi5lbWl0KFwidW5leHBlY3RlZC1yZXNwb25zZVwiLCByZXEsIHJlcykpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlJDEoXG4gICAgICAgIHdlYnNvY2tldDIsXG4gICAgICAgIHJlcSxcbiAgICAgICAgYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlOiAke3Jlcy5zdGF0dXNDb2RlfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmVxLm9uKFwidXBncmFkZVwiLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICB3ZWJzb2NrZXQyLmVtaXQoXCJ1cGdyYWRlXCIsIHJlcyk7XG4gICAgaWYgKHdlYnNvY2tldDIucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0JDEuQ09OTkVDVElORylcbiAgICAgIHJldHVybjtcbiAgICByZXEgPSB3ZWJzb2NrZXQyLl9yZXEgPSBudWxsO1xuICAgIGlmIChyZXMuaGVhZGVycy51cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBcIkludmFsaWQgVXBncmFkZSBoZWFkZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2gkMShcInNoYTFcIikudXBkYXRlKGtleSArIEdVSUQkMSkuZGlnZXN0KFwiYmFzZTY0XCIpO1xuICAgIGlmIChyZXMuaGVhZGVyc1tcInNlYy13ZWJzb2NrZXQtYWNjZXB0XCJdICE9PSBkaWdlc3QpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBcIkludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJQcm90ID0gcmVzLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LXByb3RvY29sXCJdO1xuICAgIGxldCBwcm90RXJyb3I7XG4gICAgaWYgKHNlcnZlclByb3QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICAgIHByb3RFcnJvciA9IFwiU2VydmVyIHNlbnQgYSBzdWJwcm90b2NvbCBidXQgbm9uZSB3YXMgcmVxdWVzdGVkXCI7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gXCJTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbFNldC5zaXplKSB7XG4gICAgICBwcm90RXJyb3IgPSBcIlNlcnZlciBzZW50IG5vIHN1YnByb3RvY29sXCI7XG4gICAgfVxuICAgIGlmIChwcm90RXJyb3IpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBwcm90RXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VydmVyUHJvdClcbiAgICAgIHdlYnNvY2tldDIuX3Byb3RvY29sID0gc2VydmVyUHJvdDtcbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnNcIl07XG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJTZXJ2ZXIgc2VudCBhIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXIgYnV0IG5vIGV4dGVuc2lvbiB3YXMgcmVxdWVzdGVkXCI7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG4gICAgICB0cnkge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2UkMShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXJcIjtcbiAgICAgICAgYWJvcnRIYW5kc2hha2UkMSh3ZWJzb2NrZXQyLCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuICAgICAgaWYgKGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fCBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUkMS5leHRlbnNpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIlNlcnZlciBpbmRpY2F0ZWQgYW4gZXh0ZW5zaW9uIHRoYXQgd2FzIG5vdCByZXF1ZXN0ZWRcIjtcbiAgICAgICAgYWJvcnRIYW5kc2hha2UkMSh3ZWJzb2NrZXQyLCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZSQxLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXJcIjtcbiAgICAgICAgYWJvcnRIYW5kc2hha2UkMSh3ZWJzb2NrZXQyLCBzb2NrZXQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3ZWJzb2NrZXQyLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlJDEuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICB9XG4gICAgd2Vic29ja2V0Mi5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBnZW5lcmF0ZU1hc2s6IG9wdHMuZ2VuZXJhdGVNYXNrLFxuICAgICAgbWF4UGF5bG9hZDogb3B0cy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRzLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuICB9KTtcbiAgaWYgKG9wdHMuZmluaXNoUmVxdWVzdCkge1xuICAgIG9wdHMuZmluaXNoUmVxdWVzdChyZXEsIHdlYnNvY2tldDIpO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0MiwgZXJyKSB7XG4gIHdlYnNvY2tldDIuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQkMS5DTE9TSU5HO1xuICB3ZWJzb2NrZXQyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICB3ZWJzb2NrZXQyLmVtaXRDbG9zZSgpO1xufVxuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHZvaWQgMDtcbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSBcIlwiKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/IFwiXCIgOiBvcHRpb25zLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2UkMSh3ZWJzb2NrZXQyLCBzdHJlYW0yLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldDIuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQkMS5DTE9TSU5HO1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UkMSk7XG4gIGlmIChzdHJlYW0yLnNldEhlYWRlcikge1xuICAgIHN0cmVhbTJba0Fib3J0ZWRdID0gdHJ1ZTtcbiAgICBzdHJlYW0yLmFib3J0KCk7XG4gICAgaWYgKHN0cmVhbTIuc29ja2V0ICYmICFzdHJlYW0yLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHN0cmVhbTIuc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0MiwgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0yLmRlc3Ryb3koZXJyKTtcbiAgICBzdHJlYW0yLm9uY2UoXCJlcnJvclwiLCB3ZWJzb2NrZXQyLmVtaXQuYmluZCh3ZWJzb2NrZXQyLCBcImVycm9yXCIpKTtcbiAgICBzdHJlYW0yLm9uY2UoXCJjbG9zZVwiLCB3ZWJzb2NrZXQyLmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldDIpKTtcbiAgfVxufVxuZnVuY3Rpb24gc2VuZEFmdGVyQ2xvc2Uod2Vic29ja2V0MiwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG4gICAgaWYgKHdlYnNvY2tldDIuX3NvY2tldClcbiAgICAgIHdlYnNvY2tldDIuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZVxuICAgICAgd2Vic29ja2V0Mi5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQyLnJlYWR5U3RhdGV9ICgke3JlYWR5U3RhdGVzW3dlYnNvY2tldDIucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0MiA9IHRoaXNba1dlYlNvY2tldCQxXTtcbiAgd2Vic29ja2V0Mi5fY2xvc2VGcmFtZVJlY2VpdmVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0Mi5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQyLl9jbG9zZUNvZGUgPSBjb2RlO1xuICBpZiAod2Vic29ja2V0Mi5fc29ja2V0W2tXZWJTb2NrZXQkMV0gPT09IHZvaWQgMClcbiAgICByZXR1cm47XG4gIHdlYnNvY2tldDIuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgc29ja2V0T25EYXRhKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldDIuX3NvY2tldCk7XG4gIGlmIChjb2RlID09PSAxMDA1KVxuICAgIHdlYnNvY2tldDIuY2xvc2UoKTtcbiAgZWxzZVxuICAgIHdlYnNvY2tldDIuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgY29uc3Qgd2Vic29ja2V0MiA9IHRoaXNba1dlYlNvY2tldCQxXTtcbiAgaWYgKCF3ZWJzb2NrZXQyLmlzUGF1c2VkKVxuICAgIHdlYnNvY2tldDIuX3NvY2tldC5yZXN1bWUoKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0MiA9IHRoaXNba1dlYlNvY2tldCQxXTtcbiAgaWYgKHdlYnNvY2tldDIuX3NvY2tldFtrV2ViU29ja2V0JDFdICE9PSB2b2lkIDApIHtcbiAgICB3ZWJzb2NrZXQyLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHNvY2tldE9uRGF0YSk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldDIuX3NvY2tldCk7XG4gICAgd2Vic29ja2V0Mi5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcbiAgfVxuICB3ZWJzb2NrZXQyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xufVxuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0JDFdLmVtaXRDbG9zZSgpO1xufVxuZnVuY3Rpb24gcmVjZWl2ZXJPbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgdGhpc1trV2ViU29ja2V0JDFdLmVtaXQoXCJtZXNzYWdlXCIsIGRhdGEsIGlzQmluYXJ5KTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0MiA9IHRoaXNba1dlYlNvY2tldCQxXTtcbiAgd2Vic29ja2V0Mi5wb25nKGRhdGEsICF3ZWJzb2NrZXQyLl9pc1NlcnZlciwgTk9PUCk7XG4gIHdlYnNvY2tldDIuZW1pdChcInBpbmdcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiByZWNlaXZlck9uUG9uZyhkYXRhKSB7XG4gIHRoaXNba1dlYlNvY2tldCQxXS5lbWl0KFwicG9uZ1wiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0yKSB7XG4gIHN0cmVhbTIucmVzdW1lKCk7XG59XG5mdW5jdGlvbiBzb2NrZXRPbkNsb3NlKCkge1xuICBjb25zdCB3ZWJzb2NrZXQyID0gdGhpc1trV2ViU29ja2V0JDFdO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgc29ja2V0T25DbG9zZSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgc29ja2V0T25FbmQpO1xuICB3ZWJzb2NrZXQyLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0JDEuQ0xPU0lORztcbiAgbGV0IGNodW5rO1xuICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJiAhd2Vic29ja2V0Mi5fY2xvc2VGcmFtZVJlY2VpdmVkICYmICF3ZWJzb2NrZXQyLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgJiYgKGNodW5rID0gd2Vic29ja2V0Mi5fc29ja2V0LnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICB3ZWJzb2NrZXQyLl9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cbiAgd2Vic29ja2V0Mi5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXNba1dlYlNvY2tldCQxXSA9IHZvaWQgMDtcbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldDIuX2Nsb3NlVGltZXIpO1xuICBpZiAod2Vic29ja2V0Mi5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHwgd2Vic29ja2V0Mi5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Mi5lbWl0Q2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB3ZWJzb2NrZXQyLl9yZWNlaXZlci5vbihcImVycm9yXCIsIHJlY2VpdmVyT25GaW5pc2gpO1xuICAgIHdlYnNvY2tldDIuX3JlY2VpdmVyLm9uKFwiZmluaXNoXCIsIHJlY2VpdmVyT25GaW5pc2gpO1xuICB9XG59XG5mdW5jdGlvbiBzb2NrZXRPbkRhdGEoY2h1bmspIHtcbiAgaWYgKCF0aGlzW2tXZWJTb2NrZXQkMV0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldDIgPSB0aGlzW2tXZWJTb2NrZXQkMV07XG4gIHdlYnNvY2tldDIuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQkMS5DTE9TSU5HO1xuICB3ZWJzb2NrZXQyLl9yZWNlaXZlci5lbmQoKTtcbiAgdGhpcy5lbmQoKTtcbn1cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IkMSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0MiA9IHRoaXNba1dlYlNvY2tldCQxXTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHNvY2tldE9uRXJyb3IkMSk7XG4gIHRoaXMub24oXCJlcnJvclwiLCBOT09QKTtcbiAgaWYgKHdlYnNvY2tldDIpIHtcbiAgICB3ZWJzb2NrZXQyLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0JDEuQ0xPU0lORztcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuY29uc3QgV2ViU29ja2V0JDIgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMod2Vic29ja2V0KTtcbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gdmFsaWRhdGlvbkV4cG9ydHM7XG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3QgcHJvdG9jb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSlcbiAgICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoaSAhPT0gMCAmJiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gOSkpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSlcbiAgICAgICAgZW5kID0gaTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ0KSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICAgIGVuZCA9IGk7XG4gICAgICBjb25zdCBwcm90b2NvbDIgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbDIpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbDJ9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICAgICAgfVxuICAgICAgcHJvdG9jb2xzLmFkZChwcm90b2NvbDIpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xuICB9XG4gIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgfVxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cbnZhciBzdWJwcm90b2NvbCQxID0geyBwYXJzZSB9O1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSQkMCQ0O1xuY29uc3QgaHR0cCA9IHJlcXVpcmUkJDIkMTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSQkNTtcbmNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbiQxO1xuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUyID0gcGVybWVzc2FnZURlZmxhdGU7XG5jb25zdCBzdWJwcm90b2NvbCA9IHN1YnByb3RvY29sJDE7XG5jb25zdCBXZWJTb2NrZXQyID0gd2Vic29ja2V0O1xuY29uc3QgeyBHVUlELCBrV2ViU29ja2V0IH0gPSBjb25zdGFudHM7XG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmFja2xvZz01MTFdIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2ZcbiAgICogICAgIHBlbmRpbmcgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnRUcmFja2luZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIHRyYWNrIGNsaWVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXSBBIGhvb2sgdG8gaGFuZGxlIHByb3RvY29sc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaG9zdF0gVGhlIGhvc3RuYW1lIHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICAgKiAgICAgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vU2VydmVyPWZhbHNlXSBFbmFibGUgbm8gc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdIEFjY2VwdCBvbmx5IGNvbm5lY3Rpb25zIG1hdGNoaW5nIHRoaXMgcGF0aFxuICAgKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPWZhbHNlXSBFbmFibGUvZGlzYWJsZVxuICAgKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3J0XSBUaGUgcG9ydCB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHsoaHR0cC5TZXJ2ZXJ8aHR0cHMuU2VydmVyKX0gW29wdGlvbnMuc2VydmVyXSBBIHByZS1jcmVhdGVkIEhUVFAvU1xuICAgKiAgICAgc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnZlcmlmeUNsaWVudF0gQSBob29rIHRvIHJlamVjdCBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5XZWJTb2NrZXQ9V2ViU29ja2V0XSBTcGVjaWZpZXMgdGhlIGBXZWJTb2NrZXRgXG4gICAqICAgICBjbGFzcyB0byB1c2UuIEl0IG11c3QgYmUgdGhlIGBXZWJTb2NrZXRgIGNsYXNzIG9yIGNsYXNzIHRoYXQgZXh0ZW5kcyBpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIEEgbGlzdGVuZXIgZm9yIHRoZSBgbGlzdGVuaW5nYCBldmVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsXG4gICAgICAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldDogV2ViU29ja2V0MixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnBvcnQgPT0gbnVsbCAmJiAhb3B0aW9ucy5zZXJ2ZXIgJiYgIW9wdGlvbnMubm9TZXJ2ZXIgfHwgb3B0aW9ucy5wb3J0ICE9IG51bGwgJiYgKG9wdGlvbnMuc2VydmVyIHx8IG9wdGlvbnMubm9TZXJ2ZXIpIHx8IG9wdGlvbnMuc2VydmVyICYmIG9wdGlvbnMubm9TZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcbiAgICAgICAgcmVzLndyaXRlSGVhZCg0MjYsIHtcbiAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXMuZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXJ2ZXIubGlzdGVuKFxuICAgICAgICBvcHRpb25zLnBvcnQsXG4gICAgICAgIG9wdGlvbnMuaG9zdCxcbiAgICAgICAgb3B0aW9ucy5iYWNrbG9nLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VydmVyKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCBcImNvbm5lY3Rpb25cIik7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgXCJsaXN0ZW5pbmdcIiksXG4gICAgICAgIGVycm9yOiB0aGlzLmVtaXQuYmluZCh0aGlzLCBcImVycm9yXCIpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlID09PSB0cnVlKVxuICAgICAgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fc3RhdGUgPSBSVU5OSU5HO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc2VydmVyKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX3NlcnZlci5hZGRyZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICBjYihuZXcgRXJyb3IoXCJUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYilcbiAgICAgIHRoaXMub25jZShcImNsb3NlXCIsIGNiKTtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fc3RhdGUgPSBDTE9TSU5HO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VlIGlmIGEgZ2l2ZW4gcmVxdWVzdCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGlzIHNlcnZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFJlcXVlc3Qgb2JqZWN0IHRvIGluc3BlY3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSByZXF1ZXN0IGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2hvdWxkSGFuZGxlKHJlcSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgY29uc3QgaW5kZXggPSByZXEudXJsLmluZGV4T2YoXCI/XCIpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG4gICAgICBpZiAocGF0aG5hbWUgIT09IHRoaXMub3B0aW9ucy5wYXRoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oXCJlcnJvclwiLCBzb2NrZXRPbkVycm9yKTtcbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1tcInNlYy13ZWJzb2NrZXQta2V5XCJdO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LXZlcnNpb25cIl07XG4gICAgaWYgKHJlcS5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkludmFsaWQgSFRUUCBtZXRob2RcIjtcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcS5oZWFkZXJzLnVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBVcGdyYWRlIGhlYWRlclwiO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWtleSB8fCAha2V5UmVnZXgudGVzdChrZXkpKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyXCI7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uICE9PSA4ICYmIHZlcnNpb24gIT09IDEzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlclwiO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2hvdWxkSGFuZGxlKHJlcSkpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1tcInNlYy13ZWJzb2NrZXQtcHJvdG9jb2xcIl07XG4gICAgbGV0IHByb3RvY29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB2b2lkIDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyXCI7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnNcIl07XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgJiYgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZTIoXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5vcHRpb25zLm1heFBheWxvYWRcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUyLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZTIuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUyLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyXCI7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudCkge1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOiByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gXCJzZWMtd2Vic29ja2V0LW9yaWdpblwiIDogXCJvcmlnaW5cIn1gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpXG4gICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICB9XG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpXG4gICAgICByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwic2VydmVyLmhhbmRsZVVwZ3JhZGUoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpXG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goXCJzaGExXCIpLnVwZGF0ZShrZXkgKyBHVUlEKS5kaWdlc3QoXCJiYXNlNjRcIik7XG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgIFwiSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgICAgIFwiVXBncmFkZTogd2Vic29ja2V0XCIsXG4gICAgICBcIkNvbm5lY3Rpb246IFVwZ3JhZGVcIixcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsKTtcbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyA/IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzLCByZXEpIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZTIuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUyLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZTIuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGhlYWRlcnMsIHJlcSk7XG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KFwiXFxyXFxuXCIpLmpvaW4oXCJcXHJcXG5cIikpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHNvY2tldE9uRXJyb3IpO1xuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2Iod3MsIHJlcSk7XG4gIH1cbn1cbnZhciB3ZWJzb2NrZXRTZXJ2ZXIgPSBXZWJTb2NrZXRTZXJ2ZXI7XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoc2VydmVyLCBtYXApIHtcbiAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKVxuICAgIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG4gIHJldHVybiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyhtYXApKSB7XG4gICAgICBzZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIG1hcFtldmVudF0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGVtaXRDbG9zZShzZXJ2ZXIpIHtcbiAgc2VydmVyLl9zdGF0ZSA9IENMT1NFRDtcbiAgc2VydmVyLmVtaXQoXCJjbG9zZVwiKTtcbn1cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246IFwiY2xvc2VcIixcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiLFxuICAgIFwiQ29udGVudC1MZW5ndGhcIjogQnVmZmVyLmJ5dGVMZW5ndGgobWVzc2FnZSksXG4gICAgLi4uaGVhZGVyc1xuICB9O1xuICBzb2NrZXQub25jZShcImZpbmlzaFwiLCBzb2NrZXQuZGVzdHJveSk7XG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcbmAgKyBPYmplY3Qua2V5cyhoZWFkZXJzKS5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YCkuam9pbihcIlxcclxcblwiKSArIFwiXFxyXFxuXFxyXFxuXCIgKyBtZXNzYWdlXG4gICk7XG59XG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3Ioc2VydmVyLCByZXEsIHNvY2tldCwgY29kZSwgbWVzc2FnZSkge1xuICBpZiAoc2VydmVyLmxpc3RlbmVyQ291bnQoXCJ3c0NsaWVudEVycm9yXCIpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcbiAgICBzZXJ2ZXIuZW1pdChcIndzQ2xpZW50RXJyb3JcIiwgZXJyLCBzb2NrZXQsIHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlKTtcbiAgfVxufVxuY29uc3Qgd2Vic29ja2V0U2VydmVyJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMod2Vic29ja2V0U2VydmVyKTtcbmV4cG9ydCB7XG4gIHJlY2VpdmVyJDEgYXMgUmVjZWl2ZXIsXG4gIHNlbmRlciQxIGFzIFNlbmRlcixcbiAgV2ViU29ja2V0JDIgYXMgV2ViU29ja2V0LFxuICB3ZWJzb2NrZXRTZXJ2ZXIkMSBhcyBXZWJTb2NrZXRTZXJ2ZXIsXG4gIHN0cmVhbSQxIGFzIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSxcbiAgV2ViU29ja2V0JDIgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@gradio/client/dist/wrapper-CviSselG.js\n");

/***/ })

};
;